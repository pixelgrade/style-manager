/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 184:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ 119:
/***/ (function(module) {

// Generated by Haxe 3.4.4
var hsluv = hsluv || {};
hsluv.Geometry = function() { };
hsluv.Geometry.intersectLineLine = function(a,b) {
	var x = (a.intercept - b.intercept) / (b.slope - a.slope);
	var y = a.slope * x + a.intercept;
	return { x : x, y : y};
};
hsluv.Geometry.distanceFromOrigin = function(point) {
	return Math.sqrt(Math.pow(point.x,2) + Math.pow(point.y,2));
};
hsluv.Geometry.distanceLineFromOrigin = function(line) {
	return Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope,2) + 1);
};
hsluv.Geometry.perpendicularThroughPoint = function(line,point) {
	var slope = -1 / line.slope;
	var intercept = point.y - slope * point.x;
	return { slope : slope, intercept : intercept};
};
hsluv.Geometry.angleFromOrigin = function(point) {
	return Math.atan2(point.y,point.x);
};
hsluv.Geometry.normalizeAngle = function(angle) {
	var m = 2 * Math.PI;
	return (angle % m + m) % m;
};
hsluv.Geometry.lengthOfRayUntilIntersect = function(theta,line) {
	return line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));
};
hsluv.Hsluv = function() { };
hsluv.Hsluv.getBounds = function(L) {
	var result = [];
	var sub1 = Math.pow(L + 16,3) / 1560896;
	var sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;
	var _g = 0;
	while(_g < 3) {
		var c = _g++;
		var m1 = hsluv.Hsluv.m[c][0];
		var m2 = hsluv.Hsluv.m[c][1];
		var m3 = hsluv.Hsluv.m[c][2];
		var _g1 = 0;
		while(_g1 < 2) {
			var t = _g1++;
			var top1 = (284517 * m1 - 94839 * m3) * sub2;
			var top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;
			var bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;
			result.push({ slope : top1 / bottom, intercept : top2 / bottom});
		}
	}
	return result;
};
hsluv.Hsluv.maxSafeChromaForL = function(L) {
	var bounds = hsluv.Hsluv.getBounds(L);
	var min = Infinity;
	var _g = 0;
	while(_g < bounds.length) {
		var bound = bounds[_g];
		++_g;
		var length = hsluv.Geometry.distanceLineFromOrigin(bound);
		min = Math.min(min,length);
	}
	return min;
};
hsluv.Hsluv.maxChromaForLH = function(L,H) {
	var hrad = H / 360 * Math.PI * 2;
	var bounds = hsluv.Hsluv.getBounds(L);
	var min = Infinity;
	var _g = 0;
	while(_g < bounds.length) {
		var bound = bounds[_g];
		++_g;
		var length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad,bound);
		if(length >= 0) {
			min = Math.min(min,length);
		}
	}
	return min;
};
hsluv.Hsluv.dotProduct = function(a,b) {
	var sum = 0;
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		sum += a[i] * b[i];
	}
	return sum;
};
hsluv.Hsluv.fromLinear = function(c) {
	if(c <= 0.0031308) {
		return 12.92 * c;
	} else {
		return 1.055 * Math.pow(c,0.416666666666666685) - 0.055;
	}
};
hsluv.Hsluv.toLinear = function(c) {
	if(c > 0.04045) {
		return Math.pow((c + 0.055) / 1.055,2.4);
	} else {
		return c / 12.92;
	}
};
hsluv.Hsluv.xyzToRgb = function(tuple) {
	return [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1],tuple)),hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2],tuple))];
};
hsluv.Hsluv.rgbToXyz = function(tuple) {
	var rgbl = [hsluv.Hsluv.toLinear(tuple[0]),hsluv.Hsluv.toLinear(tuple[1]),hsluv.Hsluv.toLinear(tuple[2])];
	return [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1],rgbl),hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2],rgbl)];
};
hsluv.Hsluv.yToL = function(Y) {
	if(Y <= hsluv.Hsluv.epsilon) {
		return Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;
	} else {
		return 116 * Math.pow(Y / hsluv.Hsluv.refY,0.333333333333333315) - 16;
	}
};
hsluv.Hsluv.lToY = function(L) {
	if(L <= 8) {
		return hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;
	} else {
		return hsluv.Hsluv.refY * Math.pow((L + 16) / 116,3);
	}
};
hsluv.Hsluv.xyzToLuv = function(tuple) {
	var X = tuple[0];
	var Y = tuple[1];
	var Z = tuple[2];
	var divider = X + 15 * Y + 3 * Z;
	var varU = 4 * X;
	var varV = 9 * Y;
	if(divider != 0) {
		varU /= divider;
		varV /= divider;
	} else {
		varU = NaN;
		varV = NaN;
	}
	var L = hsluv.Hsluv.yToL(Y);
	if(L == 0) {
		return [0,0,0];
	}
	var U = 13 * L * (varU - hsluv.Hsluv.refU);
	var V = 13 * L * (varV - hsluv.Hsluv.refV);
	return [L,U,V];
};
hsluv.Hsluv.luvToXyz = function(tuple) {
	var L = tuple[0];
	var U = tuple[1];
	var V = tuple[2];
	if(L == 0) {
		return [0,0,0];
	}
	var varU = U / (13 * L) + hsluv.Hsluv.refU;
	var varV = V / (13 * L) + hsluv.Hsluv.refV;
	var Y = hsluv.Hsluv.lToY(L);
	var X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);
	var Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);
	return [X,Y,Z];
};
hsluv.Hsluv.luvToLch = function(tuple) {
	var L = tuple[0];
	var U = tuple[1];
	var V = tuple[2];
	var C = Math.sqrt(U * U + V * V);
	var H;
	if(C < 0.00000001) {
		H = 0;
	} else {
		var Hrad = Math.atan2(V,U);
		H = Hrad * 180.0 / Math.PI;
		if(H < 0) {
			H = 360 + H;
		}
	}
	return [L,C,H];
};
hsluv.Hsluv.lchToLuv = function(tuple) {
	var L = tuple[0];
	var C = tuple[1];
	var H = tuple[2];
	var Hrad = H / 360.0 * 2 * Math.PI;
	var U = Math.cos(Hrad) * C;
	var V = Math.sin(Hrad) * C;
	return [L,U,V];
};
hsluv.Hsluv.hsluvToLch = function(tuple) {
	var H = tuple[0];
	var S = tuple[1];
	var L = tuple[2];
	if(L > 99.9999999) {
		return [100,0,H];
	}
	if(L < 0.00000001) {
		return [0,0,H];
	}
	var max = hsluv.Hsluv.maxChromaForLH(L,H);
	var C = max / 100 * S;
	return [L,C,H];
};
hsluv.Hsluv.lchToHsluv = function(tuple) {
	var L = tuple[0];
	var C = tuple[1];
	var H = tuple[2];
	if(L > 99.9999999) {
		return [H,0,100];
	}
	if(L < 0.00000001) {
		return [H,0,0];
	}
	var max = hsluv.Hsluv.maxChromaForLH(L,H);
	var S = C / max * 100;
	return [H,S,L];
};
hsluv.Hsluv.hpluvToLch = function(tuple) {
	var H = tuple[0];
	var S = tuple[1];
	var L = tuple[2];
	if(L > 99.9999999) {
		return [100,0,H];
	}
	if(L < 0.00000001) {
		return [0,0,H];
	}
	var max = hsluv.Hsluv.maxSafeChromaForL(L);
	var C = max / 100 * S;
	return [L,C,H];
};
hsluv.Hsluv.lchToHpluv = function(tuple) {
	var L = tuple[0];
	var C = tuple[1];
	var H = tuple[2];
	if(L > 99.9999999) {
		return [H,0,100];
	}
	if(L < 0.00000001) {
		return [H,0,0];
	}
	var max = hsluv.Hsluv.maxSafeChromaForL(L);
	var S = C / max * 100;
	return [H,S,L];
};
hsluv.Hsluv.rgbToHex = function(tuple) {
	var h = "#";
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var chan = tuple[i];
		var c = Math.round(chan * 255);
		var digit2 = c % 16;
		var digit1 = (c - digit2) / 16 | 0;
		h += hsluv.Hsluv.hexChars.charAt(digit1) + hsluv.Hsluv.hexChars.charAt(digit2);
	}
	return h;
};
hsluv.Hsluv.hexToRgb = function(hex) {
	hex = hex.toLowerCase();
	var ret = [];
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var digit1 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 1));
		var digit2 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 2));
		var n = digit1 * 16 + digit2;
		ret.push(n / 255.0);
	}
	return ret;
};
hsluv.Hsluv.lchToRgb = function(tuple) {
	return hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));
};
hsluv.Hsluv.rgbToLch = function(tuple) {
	return hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));
};
hsluv.Hsluv.hsluvToRgb = function(tuple) {
	return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));
};
hsluv.Hsluv.rgbToHsluv = function(tuple) {
	return hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));
};
hsluv.Hsluv.hpluvToRgb = function(tuple) {
	return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));
};
hsluv.Hsluv.rgbToHpluv = function(tuple) {
	return hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));
};
hsluv.Hsluv.hsluvToHex = function(tuple) {
	return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));
};
hsluv.Hsluv.hpluvToHex = function(tuple) {
	return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));
};
hsluv.Hsluv.hexToHsluv = function(s) {
	return hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));
};
hsluv.Hsluv.hexToHpluv = function(s) {
	return hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));
};
hsluv.Hsluv.m = [[3.240969941904521,-1.537383177570093,-0.498610760293],[-0.96924363628087,1.87596750150772,0.041555057407175],[0.055630079696993,-0.20397695888897,1.056971514242878]];
hsluv.Hsluv.minv = [[0.41239079926595,0.35758433938387,0.18048078840183],[0.21263900587151,0.71516867876775,0.072192315360733],[0.019330818715591,0.11919477979462,0.95053215224966]];
hsluv.Hsluv.refY = 1.0;
hsluv.Hsluv.refU = 0.19783000664283;
hsluv.Hsluv.refV = 0.46831999493879;
hsluv.Hsluv.kappa = 903.2962962;
hsluv.Hsluv.epsilon = 0.0088564516;
hsluv.Hsluv.hexChars = "0123456789abcdef";
var root = {
    "hsluvToRgb": hsluv.Hsluv.hsluvToRgb,
    "rgbToHsluv": hsluv.Hsluv.rgbToHsluv,
    "hpluvToRgb": hsluv.Hsluv.hpluvToRgb,
    "rgbToHpluv": hsluv.Hsluv.rgbToHpluv,
    "hsluvToHex": hsluv.Hsluv.hsluvToHex,
    "hexToHsluv": hsluv.Hsluv.hexToHsluv,
    "hpluvToHex": hsluv.Hsluv.hpluvToHex,
    "hexToHpluv": hsluv.Hsluv.hexToHpluv,
    "lchToHpluv": hsluv.Hsluv.lchToHpluv,
    "hpluvToLch": hsluv.Hsluv.hpluvToLch,
    "lchToHsluv": hsluv.Hsluv.lchToHsluv,
    "hsluvToLch": hsluv.Hsluv.hsluvToLch,
    "lchToLuv": hsluv.Hsluv.lchToLuv,
    "luvToLch": hsluv.Hsluv.luvToLch,
    "xyzToLuv": hsluv.Hsluv.xyzToLuv,
    "luvToXyz": hsluv.Hsluv.luvToXyz,
    "xyzToRgb": hsluv.Hsluv.xyzToRgb,
    "rgbToXyz": hsluv.Hsluv.rgbToXyz,
    "lchToRgb": hsluv.Hsluv.lchToRgb,
    "rgbToLch": hsluv.Hsluv.rgbToLch
};

module.exports = root;


/***/ }),

/***/ 854:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

var SpriteSymbol = function SpriteSymbol(ref) {
  var id = ref.id;
  var viewBox = ref.viewBox;
  var content = ref.content;

  this.id = id;
  this.viewBox = viewBox;
  this.content = content;
};

/**
 * @return {string}
 */
SpriteSymbol.prototype.stringify = function stringify () {
  return this.content;
};

/**
 * @return {string}
 */
SpriteSymbol.prototype.toString = function toString () {
  return this.stringify();
};

SpriteSymbol.prototype.destroy = function destroy () {
    var this$1 = this;

  ['id', 'viewBox', 'content'].forEach(function (prop) { return delete this$1[prop]; });
};

/**
 * @param {string} content
 * @return {Element}
 */
var parse = function (content) {
  var hasImportNode = !!document.importNode;
  var doc = new DOMParser().parseFromString(content, 'image/svg+xml').documentElement;

  /**
   * Fix for browser which are throwing WrongDocumentError
   * if you insert an element which is not part of the document
   * @see http://stackoverflow.com/a/7986519/4624403
   */
  if (hasImportNode) {
    return document.importNode(doc, true);
  }

  return doc;
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var deepmerge = createCommonjsModule(function (module, exports) {
(function (root, factory) {
    if (false) {} else {
        module.exports = factory();
    }
}(commonjsGlobal, function () {

function isMergeableObject(val) {
    var nonNullObject = val && typeof val === 'object';

    return nonNullObject
        && Object.prototype.toString.call(val) !== '[object RegExp]'
        && Object.prototype.toString.call(val) !== '[object Date]'
}

function emptyTarget(val) {
    return Array.isArray(val) ? [] : {}
}

function cloneIfNecessary(value, optionsArgument) {
    var clone = optionsArgument && optionsArgument.clone === true;
    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
}

function defaultArrayMerge(target, source, optionsArgument) {
    var destination = target.slice();
    source.forEach(function(e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
        } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
        }
    });
    return destination
}

function mergeObject(target, source, optionsArgument) {
    var destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function (key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
        } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
        }
    });
    return destination
}

function deepmerge(target, source, optionsArgument) {
    var array = Array.isArray(source);
    var options = optionsArgument || { arrayMerge: defaultArrayMerge };
    var arrayMerge = options.arrayMerge || defaultArrayMerge;

    if (array) {
        return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)
    } else {
        return mergeObject(target, source, optionsArgument)
    }
}

deepmerge.all = function deepmergeAll(array, optionsArgument) {
    if (!Array.isArray(array) || array.length < 2) {
        throw new Error('first argument should be an array with at least two elements')
    }

    // we are sure there are at least 2 values, so it is safe to have no initial value
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, optionsArgument)
    })
};

return deepmerge

}));
});

var namespaces_1 = createCommonjsModule(function (module, exports) {
var namespaces = {
  svg: {
    name: 'xmlns',
    uri: 'http://www.w3.org/2000/svg'
  },
  xlink: {
    name: 'xmlns:xlink',
    uri: 'http://www.w3.org/1999/xlink'
  }
};

exports.default = namespaces;
module.exports = exports.default;
});

/**
 * @param {Object} attrs
 * @return {string}
 */
var objectToAttrsString = function (attrs) {
  return Object.keys(attrs).map(function (attr) {
    var value = attrs[attr].toString().replace(/"/g, '&quot;');
    return (attr + "=\"" + value + "\"");
  }).join(' ');
};

var svg = namespaces_1.svg;
var xlink = namespaces_1.xlink;

var defaultAttrs = {};
defaultAttrs[svg.name] = svg.uri;
defaultAttrs[xlink.name] = xlink.uri;

/**
 * @param {string} [content]
 * @param {Object} [attributes]
 * @return {string}
 */
var wrapInSvgString = function (content, attributes) {
  if ( content === void 0 ) content = '';

  var attrs = deepmerge(defaultAttrs, attributes || {});
  var attrsRendered = objectToAttrsString(attrs);
  return ("<svg " + attrsRendered + ">" + content + "</svg>");
};

var BrowserSpriteSymbol = (function (SpriteSymbol$$1) {
  function BrowserSpriteSymbol () {
    SpriteSymbol$$1.apply(this, arguments);
  }

  if ( SpriteSymbol$$1 ) BrowserSpriteSymbol.__proto__ = SpriteSymbol$$1;
  BrowserSpriteSymbol.prototype = Object.create( SpriteSymbol$$1 && SpriteSymbol$$1.prototype );
  BrowserSpriteSymbol.prototype.constructor = BrowserSpriteSymbol;

  var prototypeAccessors = { isMounted: {} };

  prototypeAccessors.isMounted.get = function () {
    return !!this.node;
  };

  /**
   * @param {Element} node
   * @return {BrowserSpriteSymbol}
   */
  BrowserSpriteSymbol.createFromExistingNode = function createFromExistingNode (node) {
    return new BrowserSpriteSymbol({
      id: node.getAttribute('id'),
      viewBox: node.getAttribute('viewBox'),
      content: node.outerHTML
    });
  };

  BrowserSpriteSymbol.prototype.destroy = function destroy () {
    if (this.isMounted) {
      this.unmount();
    }
    SpriteSymbol$$1.prototype.destroy.call(this);
  };

  /**
   * @param {Element|string} target
   * @return {Element}
   */
  BrowserSpriteSymbol.prototype.mount = function mount (target) {
    if (this.isMounted) {
      return this.node;
    }

    var mountTarget = typeof target === 'string' ? document.querySelector(target) : target;
    var node = this.render();
    this.node = node;

    mountTarget.appendChild(node);

    return node;
  };

  /**
   * @return {Element}
   */
  BrowserSpriteSymbol.prototype.render = function render () {
    var content = this.stringify();
    return parse(wrapInSvgString(content)).childNodes[0];
  };

  BrowserSpriteSymbol.prototype.unmount = function unmount () {
    this.node.parentNode.removeChild(this.node);
  };

  Object.defineProperties( BrowserSpriteSymbol.prototype, prototypeAccessors );

  return BrowserSpriteSymbol;
}(SpriteSymbol));

return BrowserSpriteSymbol;

})));


/***/ }),

/***/ 348:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var deepmerge = createCommonjsModule(function (module, exports) {
(function (root, factory) {
    if (false) {} else {
        module.exports = factory();
    }
}(commonjsGlobal, function () {

function isMergeableObject(val) {
    var nonNullObject = val && typeof val === 'object';

    return nonNullObject
        && Object.prototype.toString.call(val) !== '[object RegExp]'
        && Object.prototype.toString.call(val) !== '[object Date]'
}

function emptyTarget(val) {
    return Array.isArray(val) ? [] : {}
}

function cloneIfNecessary(value, optionsArgument) {
    var clone = optionsArgument && optionsArgument.clone === true;
    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
}

function defaultArrayMerge(target, source, optionsArgument) {
    var destination = target.slice();
    source.forEach(function(e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
        } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
        }
    });
    return destination
}

function mergeObject(target, source, optionsArgument) {
    var destination = {};
    if (isMergeableObject(target)) {
        Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function (key) {
        if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
        } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
        }
    });
    return destination
}

function deepmerge(target, source, optionsArgument) {
    var array = Array.isArray(source);
    var options = optionsArgument || { arrayMerge: defaultArrayMerge };
    var arrayMerge = options.arrayMerge || defaultArrayMerge;

    if (array) {
        return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)
    } else {
        return mergeObject(target, source, optionsArgument)
    }
}

deepmerge.all = function deepmergeAll(array, optionsArgument) {
    if (!Array.isArray(array) || array.length < 2) {
        throw new Error('first argument should be an array with at least two elements')
    }

    // we are sure there are at least 2 values, so it is safe to have no initial value
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, optionsArgument)
    })
};

return deepmerge

}));
});

//      
// An event handler can take an optional event argument
// and should not return a value
                                          
// An array of all currently registered event handlers for a type
                                            
// A map of event types and their corresponding event handlers.
                        
                                   
  

/** Mitt: Tiny (~200b) functional event emitter / pubsub.
 *  @name mitt
 *  @returns {Mitt}
 */
function mitt(all                 ) {
	all = all || Object.create(null);

	return {
		/**
		 * Register an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to listen for, or `"*"` for all events
		 * @param  {Function} handler Function to call in response to given event
		 * @memberOf mitt
		 */
		on: function on(type        , handler              ) {
			(all[type] || (all[type] = [])).push(handler);
		},

		/**
		 * Remove an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
		 * @param  {Function} handler Handler function to remove
		 * @memberOf mitt
		 */
		off: function off(type        , handler              ) {
			if (all[type]) {
				all[type].splice(all[type].indexOf(handler) >>> 0, 1);
			}
		},

		/**
		 * Invoke all handlers for the given type.
		 * If present, `"*"` handlers are invoked after type-matched handlers.
		 *
		 * @param {String} type  The event type to invoke
		 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
		 * @memberof mitt
		 */
		emit: function emit(type        , evt     ) {
			(all[type] || []).map(function (handler) { handler(evt); });
			(all['*'] || []).map(function (handler) { handler(type, evt); });
		}
	};
}

var namespaces_1 = createCommonjsModule(function (module, exports) {
var namespaces = {
  svg: {
    name: 'xmlns',
    uri: 'http://www.w3.org/2000/svg'
  },
  xlink: {
    name: 'xmlns:xlink',
    uri: 'http://www.w3.org/1999/xlink'
  }
};

exports.default = namespaces;
module.exports = exports.default;
});

/**
 * @param {Object} attrs
 * @return {string}
 */
var objectToAttrsString = function (attrs) {
  return Object.keys(attrs).map(function (attr) {
    var value = attrs[attr].toString().replace(/"/g, '&quot;');
    return (attr + "=\"" + value + "\"");
  }).join(' ');
};

var svg = namespaces_1.svg;
var xlink = namespaces_1.xlink;

var defaultAttrs = {};
defaultAttrs[svg.name] = svg.uri;
defaultAttrs[xlink.name] = xlink.uri;

/**
 * @param {string} [content]
 * @param {Object} [attributes]
 * @return {string}
 */
var wrapInSvgString = function (content, attributes) {
  if ( content === void 0 ) content = '';

  var attrs = deepmerge(defaultAttrs, attributes || {});
  var attrsRendered = objectToAttrsString(attrs);
  return ("<svg " + attrsRendered + ">" + content + "</svg>");
};

var svg$1 = namespaces_1.svg;
var xlink$1 = namespaces_1.xlink;

var defaultConfig = {
  attrs: ( obj = {
    style: ['position: absolute', 'width: 0', 'height: 0'].join('; '),
    'aria-hidden': 'true'
  }, obj[svg$1.name] = svg$1.uri, obj[xlink$1.name] = xlink$1.uri, obj )
};
var obj;

var Sprite = function Sprite(config) {
  this.config = deepmerge(defaultConfig, config || {});
  this.symbols = [];
};

/**
 * Add new symbol. If symbol with the same id exists it will be replaced.
 * @param {SpriteSymbol} symbol
 * @return {boolean} `true` - symbol was added, `false` - replaced
 */
Sprite.prototype.add = function add (symbol) {
  var ref = this;
    var symbols = ref.symbols;
  var existing = this.find(symbol.id);

  if (existing) {
    symbols[symbols.indexOf(existing)] = symbol;
    return false;
  }

  symbols.push(symbol);
  return true;
};

/**
 * Remove symbol & destroy it
 * @param {string} id
 * @return {boolean} `true` - symbol was found & successfully destroyed, `false` - otherwise
 */
Sprite.prototype.remove = function remove (id) {
  var ref = this;
    var symbols = ref.symbols;
  var symbol = this.find(id);

  if (symbol) {
    symbols.splice(symbols.indexOf(symbol), 1);
    symbol.destroy();
    return true;
  }

  return false;
};

/**
 * @param {string} id
 * @return {SpriteSymbol|null}
 */
Sprite.prototype.find = function find (id) {
  return this.symbols.filter(function (s) { return s.id === id; })[0] || null;
};

/**
 * @param {string} id
 * @return {boolean}
 */
Sprite.prototype.has = function has (id) {
  return this.find(id) !== null;
};

/**
 * @return {string}
 */
Sprite.prototype.stringify = function stringify () {
  var ref = this.config;
    var attrs = ref.attrs;
  var stringifiedSymbols = this.symbols.map(function (s) { return s.stringify(); }).join('');
  return wrapInSvgString(stringifiedSymbols, attrs);
};

/**
 * @return {string}
 */
Sprite.prototype.toString = function toString () {
  return this.stringify();
};

Sprite.prototype.destroy = function destroy () {
  this.symbols.forEach(function (s) { return s.destroy(); });
};

var SpriteSymbol = function SpriteSymbol(ref) {
  var id = ref.id;
  var viewBox = ref.viewBox;
  var content = ref.content;

  this.id = id;
  this.viewBox = viewBox;
  this.content = content;
};

/**
 * @return {string}
 */
SpriteSymbol.prototype.stringify = function stringify () {
  return this.content;
};

/**
 * @return {string}
 */
SpriteSymbol.prototype.toString = function toString () {
  return this.stringify();
};

SpriteSymbol.prototype.destroy = function destroy () {
    var this$1 = this;

  ['id', 'viewBox', 'content'].forEach(function (prop) { return delete this$1[prop]; });
};

/**
 * @param {string} content
 * @return {Element}
 */
var parse = function (content) {
  var hasImportNode = !!document.importNode;
  var doc = new DOMParser().parseFromString(content, 'image/svg+xml').documentElement;

  /**
   * Fix for browser which are throwing WrongDocumentError
   * if you insert an element which is not part of the document
   * @see http://stackoverflow.com/a/7986519/4624403
   */
  if (hasImportNode) {
    return document.importNode(doc, true);
  }

  return doc;
};

var BrowserSpriteSymbol = (function (SpriteSymbol$$1) {
  function BrowserSpriteSymbol () {
    SpriteSymbol$$1.apply(this, arguments);
  }

  if ( SpriteSymbol$$1 ) BrowserSpriteSymbol.__proto__ = SpriteSymbol$$1;
  BrowserSpriteSymbol.prototype = Object.create( SpriteSymbol$$1 && SpriteSymbol$$1.prototype );
  BrowserSpriteSymbol.prototype.constructor = BrowserSpriteSymbol;

  var prototypeAccessors = { isMounted: {} };

  prototypeAccessors.isMounted.get = function () {
    return !!this.node;
  };

  /**
   * @param {Element} node
   * @return {BrowserSpriteSymbol}
   */
  BrowserSpriteSymbol.createFromExistingNode = function createFromExistingNode (node) {
    return new BrowserSpriteSymbol({
      id: node.getAttribute('id'),
      viewBox: node.getAttribute('viewBox'),
      content: node.outerHTML
    });
  };

  BrowserSpriteSymbol.prototype.destroy = function destroy () {
    if (this.isMounted) {
      this.unmount();
    }
    SpriteSymbol$$1.prototype.destroy.call(this);
  };

  /**
   * @param {Element|string} target
   * @return {Element}
   */
  BrowserSpriteSymbol.prototype.mount = function mount (target) {
    if (this.isMounted) {
      return this.node;
    }

    var mountTarget = typeof target === 'string' ? document.querySelector(target) : target;
    var node = this.render();
    this.node = node;

    mountTarget.appendChild(node);

    return node;
  };

  /**
   * @return {Element}
   */
  BrowserSpriteSymbol.prototype.render = function render () {
    var content = this.stringify();
    return parse(wrapInSvgString(content)).childNodes[0];
  };

  BrowserSpriteSymbol.prototype.unmount = function unmount () {
    this.node.parentNode.removeChild(this.node);
  };

  Object.defineProperties( BrowserSpriteSymbol.prototype, prototypeAccessors );

  return BrowserSpriteSymbol;
}(SpriteSymbol));

var defaultConfig$1 = {
  /**
   * Should following options be automatically configured:
   * - `syncUrlsWithBaseTag`
   * - `locationChangeAngularEmitter`
   * - `moveGradientsOutsideSymbol`
   * @type {boolean}
   */
  autoConfigure: true,

  /**
   * Default mounting selector
   * @type {string}
   */
  mountTo: 'body',

  /**
   * Fix disappearing SVG elements when <base href> exists.
   * Executes when sprite mounted.
   * @see http://stackoverflow.com/a/18265336/796152
   * @see https://github.com/everdimension/angular-svg-base-fix
   * @see https://github.com/angular/angular.js/issues/8934#issuecomment-56568466
   * @type {boolean}
   */
  syncUrlsWithBaseTag: false,

  /**
   * Should sprite listen custom location change event
   * @type {boolean}
   */
  listenLocationChangeEvent: true,

  /**
   * Custom window event name which should be emitted to update sprite urls
   * @type {string}
   */
  locationChangeEvent: 'locationChange',

  /**
   * Emit location change event in Angular automatically
   * @type {boolean}
   */
  locationChangeAngularEmitter: false,

  /**
   * Selector to find symbols usages when updating sprite urls
   * @type {string}
   */
  usagesToUpdate: 'use[*|href]',

  /**
   * Fix Firefox bug when gradients and patterns don't work if they are within a symbol.
   * Executes when sprite is rendered, but not mounted.
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=306674
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=353575
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1235364
   * @type {boolean}
   */
  moveGradientsOutsideSymbol: false
};

/**
 * @param {*} arrayLike
 * @return {Array}
 */
var arrayFrom = function (arrayLike) {
  return Array.prototype.slice.call(arrayLike, 0);
};

var browser = {
  isChrome: function () { return /chrome/i.test(navigator.userAgent); },
  isFirefox: function () { return /firefox/i.test(navigator.userAgent); },

  // https://msdn.microsoft.com/en-us/library/ms537503(v=vs.85).aspx
  isIE: function () { return /msie/i.test(navigator.userAgent) || /trident/i.test(navigator.userAgent); },
  isEdge: function () { return /edge/i.test(navigator.userAgent); }
};

/**
 * @param {string} name
 * @param {*} data
 */
var dispatchEvent = function (name, data) {
  var event = document.createEvent('CustomEvent');
  event.initCustomEvent(name, false, false, data);
  window.dispatchEvent(event);
};

/**
 * IE doesn't evaluate <style> tags in SVGs that are dynamically added to the page.
 * This trick will trigger IE to read and use any existing SVG <style> tags.
 * @see https://github.com/iconic/SVGInjector/issues/23
 * @see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/
 *
 * @param {Element} node DOM Element to search <style> tags in
 * @return {Array<HTMLStyleElement>}
 */
var evalStylesIEWorkaround = function (node) {
  var updatedNodes = [];

  arrayFrom(node.querySelectorAll('style'))
    .forEach(function (style) {
      style.textContent += '';
      updatedNodes.push(style);
    });

  return updatedNodes;
};

/**
 * @param {string} [url] If not provided - current URL will be used
 * @return {string}
 */
var getUrlWithoutFragment = function (url) {
  return (url || window.location.href).split('#')[0];
};

/* global angular */
/**
 * @param {string} eventName
 */
var locationChangeAngularEmitter = function (eventName) {
  angular.module('ng').run(['$rootScope', function ($rootScope) {
    $rootScope.$on('$locationChangeSuccess', function (e, newUrl, oldUrl) {
      dispatchEvent(eventName, { oldUrl: oldUrl, newUrl: newUrl });
    });
  }]);
};

var defaultSelector = 'linearGradient, radialGradient, pattern, mask, clipPath';

/**
 * @param {Element} svg
 * @param {string} [selector]
 * @return {Element}
 */
var moveGradientsOutsideSymbol = function (svg, selector) {
  if ( selector === void 0 ) selector = defaultSelector;

  arrayFrom(svg.querySelectorAll('symbol')).forEach(function (symbol) {
    arrayFrom(symbol.querySelectorAll(selector)).forEach(function (node) {
      symbol.parentNode.insertBefore(node, symbol);
    });
  });
  return svg;
};

/**
 * @param {NodeList} nodes
 * @param {Function} [matcher]
 * @return {Attr[]}
 */
function selectAttributes(nodes, matcher) {
  var attrs = arrayFrom(nodes).reduce(function (acc, node) {
    if (!node.attributes) {
      return acc;
    }

    var arrayfied = arrayFrom(node.attributes);
    var matched = matcher ? arrayfied.filter(matcher) : arrayfied;
    return acc.concat(matched);
  }, []);

  return attrs;
}

/**
 * @param {NodeList|Node} nodes
 * @param {boolean} [clone=true]
 * @return {string}
 */

var xLinkNS = namespaces_1.xlink.uri;
var xLinkAttrName = 'xlink:href';

// eslint-disable-next-line no-useless-escape
var specialUrlCharsPattern = /[{}|\\\^\[\]`"<>]/g;

function encoder(url) {
  return url.replace(specialUrlCharsPattern, function (match) {
    return ("%" + (match[0].charCodeAt(0).toString(16).toUpperCase()));
  });
}

function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}

/**
 * @param {NodeList} nodes
 * @param {string} startsWith
 * @param {string} replaceWith
 * @return {NodeList}
 */
function updateReferences(nodes, startsWith, replaceWith) {
  arrayFrom(nodes).forEach(function (node) {
    var href = node.getAttribute(xLinkAttrName);
    if (href && href.indexOf(startsWith) === 0) {
      var newUrl = href.replace(startsWith, replaceWith);
      node.setAttributeNS(xLinkNS, xLinkAttrName, newUrl);
    }
  });

  return nodes;
}

/**
 * List of SVG attributes to update url() target in them
 */
var attList = [
  'clipPath',
  'colorProfile',
  'src',
  'cursor',
  'fill',
  'filter',
  'marker',
  'markerStart',
  'markerMid',
  'markerEnd',
  'mask',
  'stroke',
  'style'
];

var attSelector = attList.map(function (attr) { return ("[" + attr + "]"); }).join(',');

/**
 * Update URLs in svg image (like `fill="url(...)"`) and update referencing elements
 * @param {Element} svg
 * @param {NodeList} references
 * @param {string|RegExp} startsWith
 * @param {string} replaceWith
 * @return {void}
 *
 * @example
 * const sprite = document.querySelector('svg.sprite');
 * const usages = document.querySelectorAll('use');
 * updateUrls(sprite, usages, '#', 'prefix#');
 */
var updateUrls = function (svg, references, startsWith, replaceWith) {
  var startsWithEncoded = encoder(startsWith);
  var replaceWithEncoded = encoder(replaceWith);

  var nodes = svg.querySelectorAll(attSelector);
  var attrs = selectAttributes(nodes, function (ref) {
    var localName = ref.localName;
    var value = ref.value;

    return attList.indexOf(localName) !== -1 && value.indexOf(("url(" + startsWithEncoded)) !== -1;
  });

  attrs.forEach(function (attr) { return attr.value = attr.value.replace(new RegExp(escapeRegExp(startsWithEncoded), 'g'), replaceWithEncoded); });
  updateReferences(references, startsWithEncoded, replaceWithEncoded);
};

/**
 * Internal emitter events
 * @enum
 * @private
 */
var Events = {
  MOUNT: 'mount',
  SYMBOL_MOUNT: 'symbol_mount'
};

var BrowserSprite = (function (Sprite$$1) {
  function BrowserSprite(cfg) {
    var this$1 = this;
    if ( cfg === void 0 ) cfg = {};

    Sprite$$1.call(this, deepmerge(defaultConfig$1, cfg));

    var emitter = mitt();
    this._emitter = emitter;
    this.node = null;

    var ref = this;
    var config = ref.config;

    if (config.autoConfigure) {
      this._autoConfigure(cfg);
    }

    if (config.syncUrlsWithBaseTag) {
      var baseUrl = document.getElementsByTagName('base')[0].getAttribute('href');
      emitter.on(Events.MOUNT, function () { return this$1.updateUrls('#', baseUrl); });
    }

    var handleLocationChange = this._handleLocationChange.bind(this);
    this._handleLocationChange = handleLocationChange;

    // Provide way to update sprite urls externally via dispatching custom window event
    if (config.listenLocationChangeEvent) {
      window.addEventListener(config.locationChangeEvent, handleLocationChange);
    }

    // Emit location change event in Angular automatically
    if (config.locationChangeAngularEmitter) {
      locationChangeAngularEmitter(config.locationChangeEvent);
    }

    // After sprite mounted
    emitter.on(Events.MOUNT, function (spriteNode) {
      if (config.moveGradientsOutsideSymbol) {
        moveGradientsOutsideSymbol(spriteNode);
      }
    });

    // After symbol mounted into sprite
    emitter.on(Events.SYMBOL_MOUNT, function (symbolNode) {
      if (config.moveGradientsOutsideSymbol) {
        moveGradientsOutsideSymbol(symbolNode.parentNode);
      }

      if (browser.isIE() || browser.isEdge()) {
        evalStylesIEWorkaround(symbolNode);
      }
    });
  }

  if ( Sprite$$1 ) BrowserSprite.__proto__ = Sprite$$1;
  BrowserSprite.prototype = Object.create( Sprite$$1 && Sprite$$1.prototype );
  BrowserSprite.prototype.constructor = BrowserSprite;

  var prototypeAccessors = { isMounted: {} };

  /**
   * @return {boolean}
   */
  prototypeAccessors.isMounted.get = function () {
    return !!this.node;
  };

  /**
   * Automatically configure following options
   * - `syncUrlsWithBaseTag`
   * - `locationChangeAngularEmitter`
   * - `moveGradientsOutsideSymbol`
   * @param {Object} cfg
   * @private
   */
  BrowserSprite.prototype._autoConfigure = function _autoConfigure (cfg) {
    var ref = this;
    var config = ref.config;

    if (typeof cfg.syncUrlsWithBaseTag === 'undefined') {
      config.syncUrlsWithBaseTag = typeof document.getElementsByTagName('base')[0] !== 'undefined';
    }

    if (typeof cfg.locationChangeAngularEmitter === 'undefined') {
        config.locationChangeAngularEmitter = typeof window.angular !== 'undefined';
    }

    if (typeof cfg.moveGradientsOutsideSymbol === 'undefined') {
      config.moveGradientsOutsideSymbol = browser.isFirefox();
    }
  };

  /**
   * @param {Event} event
   * @param {Object} event.detail
   * @param {string} event.detail.oldUrl
   * @param {string} event.detail.newUrl
   * @private
   */
  BrowserSprite.prototype._handleLocationChange = function _handleLocationChange (event) {
    var ref = event.detail;
    var oldUrl = ref.oldUrl;
    var newUrl = ref.newUrl;
    this.updateUrls(oldUrl, newUrl);
  };

  /**
   * Add new symbol. If symbol with the same id exists it will be replaced.
   * If sprite already mounted - `symbol.mount(sprite.node)` will be called.
   * @fires Events#SYMBOL_MOUNT
   * @param {BrowserSpriteSymbol} symbol
   * @return {boolean} `true` - symbol was added, `false` - replaced
   */
  BrowserSprite.prototype.add = function add (symbol) {
    var sprite = this;
    var isNewSymbol = Sprite$$1.prototype.add.call(this, symbol);

    if (this.isMounted && isNewSymbol) {
      symbol.mount(sprite.node);
      this._emitter.emit(Events.SYMBOL_MOUNT, symbol.node);
    }

    return isNewSymbol;
  };

  /**
   * Attach to existing DOM node
   * @param {string|Element} target
   * @return {Element|null} attached DOM Element. null if node to attach not found.
   */
  BrowserSprite.prototype.attach = function attach (target) {
    var this$1 = this;

    var sprite = this;

    if (sprite.isMounted) {
      return sprite.node;
    }

    /** @type Element */
    var node = typeof target === 'string' ? document.querySelector(target) : target;
    sprite.node = node;

    // Already added symbols needs to be mounted
    this.symbols.forEach(function (symbol) {
      symbol.mount(sprite.node);
      this$1._emitter.emit(Events.SYMBOL_MOUNT, symbol.node);
    });

    // Create symbols from existing DOM nodes, add and mount them
    arrayFrom(node.querySelectorAll('symbol'))
      .forEach(function (symbolNode) {
        var symbol = BrowserSpriteSymbol.createFromExistingNode(symbolNode);
        symbol.node = symbolNode; // hack to prevent symbol mounting to sprite when adding
        sprite.add(symbol);
      });

    this._emitter.emit(Events.MOUNT, node);

    return node;
  };

  BrowserSprite.prototype.destroy = function destroy () {
    var ref = this;
    var config = ref.config;
    var symbols = ref.symbols;
    var _emitter = ref._emitter;

    symbols.forEach(function (s) { return s.destroy(); });

    _emitter.off('*');
    window.removeEventListener(config.locationChangeEvent, this._handleLocationChange);

    if (this.isMounted) {
      this.unmount();
    }
  };

  /**
   * @fires Events#MOUNT
   * @param {string|Element} [target]
   * @param {boolean} [prepend=false]
   * @return {Element|null} rendered sprite node. null if mount node not found.
   */
  BrowserSprite.prototype.mount = function mount (target, prepend) {
    if ( target === void 0 ) target = this.config.mountTo;
    if ( prepend === void 0 ) prepend = false;

    var sprite = this;

    if (sprite.isMounted) {
      return sprite.node;
    }

    var mountNode = typeof target === 'string' ? document.querySelector(target) : target;
    var node = sprite.render();
    this.node = node;

    if (prepend && mountNode.childNodes[0]) {
      mountNode.insertBefore(node, mountNode.childNodes[0]);
    } else {
      mountNode.appendChild(node);
    }

    this._emitter.emit(Events.MOUNT, node);

    return node;
  };

  /**
   * @return {Element}
   */
  BrowserSprite.prototype.render = function render () {
    return parse(this.stringify());
  };

  /**
   * Detach sprite from the DOM
   */
  BrowserSprite.prototype.unmount = function unmount () {
    this.node.parentNode.removeChild(this.node);
  };

  /**
   * Update URLs in sprite and usage elements
   * @param {string} oldUrl
   * @param {string} newUrl
   * @return {boolean} `true` - URLs was updated, `false` - sprite is not mounted
   */
  BrowserSprite.prototype.updateUrls = function updateUrls$1 (oldUrl, newUrl) {
    if (!this.isMounted) {
      return false;
    }

    var usages = document.querySelectorAll(this.config.usagesToUpdate);

    updateUrls(
      this.node,
      usages,
      ((getUrlWithoutFragment(oldUrl)) + "#"),
      ((getUrlWithoutFragment(newUrl)) + "#")
    );

    return true;
  };

  Object.defineProperties( BrowserSprite.prototype, prototypeAccessors );

  return BrowserSprite;
}(Sprite));

var ready$1 = createCommonjsModule(function (module) {
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  { module.exports = definition(); }

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState);


  if (!loaded)
  { doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener);
    loaded = 1;
    while (listener = fns.shift()) { listener(); }
  }); }

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn);
  }

});
});

var spriteNodeId = '__SVG_SPRITE_NODE__';
var spriteGlobalVarName = '__SVG_SPRITE__';
var isSpriteExists = !!window[spriteGlobalVarName];

// eslint-disable-next-line import/no-mutable-exports
var sprite;

if (isSpriteExists) {
  sprite = window[spriteGlobalVarName];
} else {
  sprite = new BrowserSprite({
    attrs: {
      id: spriteNodeId,
      'aria-hidden': 'true'
    }
  });
  window[spriteGlobalVarName] = sprite;
}

var loadSprite = function () {
  /**
   * Check for page already contains sprite node
   * If found - attach to and reuse it's content
   * If not - render and mount the new sprite
   */
  var existing = document.getElementById(spriteNodeId);

  if (existing) {
    sprite.attach(existing);
  } else {
    sprite.mount(document.body, true);
  }
};

if (document.body) {
  loadSprite();
} else {
  ready$1(loadSprite);
}

var sprite$1 = sprite;

return sprite$1;

})));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "convertFontVariantToFVD": function() { return /* reexport */ convertFontVariantToFVD; },
  "determineFontType": function() { return /* reexport */ determineFontType; },
  "getCSSFromPalettes": function() { return /* reexport */ getCSSFromPalettes; },
  "getFontDetails": function() { return /* reexport */ getFontDetails; },
  "resizer": function() { return /* reexport */ resizer_namespaceObject; }
});

// NAMESPACE OBJECT: ./src/_js/customizer/resizer/index.js
var resizer_namespaceObject = {};
__webpack_require__.r(resizer_namespaceObject);
__webpack_require__.d(resizer_namespaceObject, {
  "resize": function() { return resize; },
  "setOffset": function() { return setOffset; }
});

;// CONCATENATED MODULE: external "jQuery"
var external_jQuery_namespaceObject = window["jQuery"];
var external_jQuery_default = /*#__PURE__*/__webpack_require__.n(external_jQuery_namespaceObject);
;// CONCATENATED MODULE: ./src/_js/customizer/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: external "ReactDOM"
var external_ReactDOM_namespaceObject = window["ReactDOM"];
var external_ReactDOM_default = /*#__PURE__*/__webpack_require__.n(external_ReactDOM_namespaceObject);
;// CONCATENATED MODULE: external "React"
var external_React_namespaceObject = window["React"];
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_namespaceObject);
;// CONCATENATED MODULE: external "lodash"
var external_lodash_namespaceObject = window["lodash"];
var external_lodash_default = /*#__PURE__*/__webpack_require__.n(external_lodash_namespaceObject);
;// CONCATENATED MODULE: ./src/_js/customizer/global-service.js

var callbacks = {};
var settings = {};
var overrideCustomizerBack = [];
var loadSettings = function loadSettings() {
  settings = JSON.parse(JSON.stringify(wp.customize.settings.settings));
};
var getSettings = function getSettings() {
  return settings;
};
var setSettings = function setSettings(newSettings) {
  settings = newSettings;
};
var getSetting = function getSetting(settingID) {
  return settings[settingID];
};
var getSettingConfig = function getSettingConfig(settingID) {
  return styleManager.config.settings[settingID];
};
var setSetting = function setSetting(settingID, value) {
  settings[settingID] = value;
};
var getCallback = function getCallback(settingID) {
  return callbacks[settingID];
};
var setCallback = function setCallback(settingID, callback) {
  callbacks[settingID] = callback;
};
var getCallbacks = function getCallbacks() {
  return callbacks;
};
var deleteCallbacks = function deleteCallbacks(settingIDs) {
  settingIDs.forEach(function (settingID) {
    delete callbacks[settingID];
  });
};
var getBackArray = function getBackArray() {
  return overrideCustomizerBack;
};
var addToBackArray = function addToBackArray(section) {
  overrideCustomizerBack.push(section);
};
var setBackArray = function setBackArray(newArray) {
  overrideCustomizerBack = newArray.slice();
};
var pushToBackArray = function pushToBackArray(targetSection, section) {
  var backArray = getBackArray();
  window.document.body.classList.add('remove-customizer-transitions');
  setBackArray([]);
  targetSection.focus();
  setBackArray(backArray);
  addToBackArray(section);
};
var popFromBackArray = function popFromBackArray() {
  var backArray = getBackArray();
  var targetSectionID = backArray.pop();

  if (targetSectionID) {
    wp.customize.section(targetSectionID, function (targetSection) {
      targetSection.focus();

      if (!backArray.length) {
        setTimeout(function () {
          window.document.body.classList.remove('remove-customizer-transitions');
        }, 100);
      }
    });
  }
};
var bindConnectedFields = function bindConnectedFields(settingIDs) {
  var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
  settingIDs.forEach(function (settingID) {
    wp.customize(settingID, function (parentSetting) {
      setCallback(settingID, function (newValue) {
        var settingConfig = getSetting(settingID);
        var connectedFields = settingConfig.connected_fields || {};
        Object.keys(connectedFields).map(function (key) {
          return connectedFields[key].setting_id;
        }).forEach(function (connectedSettingID) {
          wp.customize(connectedSettingID, function (connectedSetting) {
            connectedSetting.set(filter(newValue));
          });
        });
      });
      parentSetting.bind(getCallback(settingID));
    });
  });
};
var unbindConnectedFields = function unbindConnectedFields(settingIDs) {
  var globalCallbacks = external_lodash_default().pick(getCallbacks(), settingIDs);

  external_lodash_default().each(globalCallbacks, function (callback, settingID) {
    wp.customize(settingID, function (setting) {
      setting.unbind(callback);
    });
  });

  deleteCallbacks(settingIDs);
};

var noop = function noop(x) {
  return x;
};
// EXTERNAL MODULE: ./node_modules/svg-baker-runtime/browser-symbol.js
var browser_symbol = __webpack_require__(854);
var browser_symbol_default = /*#__PURE__*/__webpack_require__.n(browser_symbol);
// EXTERNAL MODULE: ./node_modules/svg-sprite-loader/runtime/browser-sprite.build.js
var browser_sprite_build = __webpack_require__(348);
var browser_sprite_build_default = /*#__PURE__*/__webpack_require__.n(browser_sprite_build);
;// CONCATENATED MODULE: ./src/_js/customizer/svg/colorize-elements.svg


var symbol = new (browser_symbol_default())({
  "id": "colorize-elements",
  "use": "colorize-elements-usage",
  "viewBox": "0 0 24 24",
  "content": "<symbol viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" id=\"colorize-elements\">\n<path d=\"M16.66 4.51945L19.49 7.34945L16.66 10.1795L13.83 7.34945L16.66 4.51945ZM9 4.99945V8.99945H5V4.99945H9ZM19 14.9995V18.9995H15V14.9995H19ZM9 14.9995V18.9995H5V14.9995H9ZM16.66 1.68945L11 7.33945L16.66 12.9995L22.32 7.33945L16.66 1.68945ZM11 2.99945H3V10.9995H11V2.99945ZM21 12.9995H13V20.9995H21V12.9995ZM11 12.9995H3V20.9995H11V12.9995Z\" fill=\"#2F384C\" />\n</symbol>"
});
var result = browser_sprite_build_default().add(symbol);
/* harmony default export */ var colorize_elements = (symbol);
;// CONCATENATED MODULE: ./src/_js/customizer/utils/use-customize-setting-callback.js


var useCustomizeSettingCallback = function useCustomizeSettingCallback(settingID, callback) {
  if (typeof callback !== "function") {
    return;
  }

  wp.customize(settingID, function (setting) {
    (0,external_React_namespaceObject.useEffect)(function () {
      setting.bind(callback);
      return function () {
        setting.unbind(callback);
      };
    }, []);
  });
};

/* harmony default export */ var use_customize_setting_callback = (useCustomizeSettingCallback);
;// CONCATENATED MODULE: external "chroma"
var external_chroma_namespaceObject = window["chroma"];
var external_chroma_default = /*#__PURE__*/__webpack_require__.n(external_chroma_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/use-debounce/esm/useDebouncedCallback.js

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked, or until the next browser frame is drawn. The debounced function
 * comes with a `cancel` method to cancel delayed `func` invocations and a
 * `flush` method to immediately invoke them. Provide `options` to indicate
 * whether `func` should be invoked on the leading and/or trailing edge of the
 * `wait` timeout. The `func` is invoked with the last arguments provided to the
 * debounced function. Subsequent calls to the debounced function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`
 * invocation will be deferred until the next frame is drawn (typically about
 * 16ms).
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `debounce` and `throttle`.
 *
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0]
 *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is
 *  used (if available, otherwise it will be setTimeout(...,0)).
 * @param {Object} [options={}] The options object.
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.leading=false]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {number} [options.maxWait]
 *  Specify invoking on the trailing edge of the timeout.
 * @param {boolean} [options.trailing=true]
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * const resizeHandler = useDebouncedCallback(calculateLayout, 150);
 * window.addEventListener('resize', resizeHandler)
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * const clickHandler = useDebouncedCallback(sendMail, 300, {
 *   leading: true,
 *   trailing: false,
 * })
 * <button onClick={clickHandler}>click me</button>
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })
 * const source = new EventSource('/stream')
 * source.addEventListener('message', debounced)
 *
 * // Cancel the trailing debounced invocation.
 * window.addEventListener('popstate', debounced.cancel)
 *
 * // Check for pending invocations.
 * const status = debounced.pending() ? "Pending..." : "Ready"
 */
function useDebouncedCallback(func, wait, options) {
    var _this = this;
    var lastCallTime = (0,external_React_namespaceObject.useRef)(null);
    var lastInvokeTime = (0,external_React_namespaceObject.useRef)(0);
    var timerId = (0,external_React_namespaceObject.useRef)(null);
    var lastArgs = (0,external_React_namespaceObject.useRef)([]);
    var lastThis = (0,external_React_namespaceObject.useRef)();
    var result = (0,external_React_namespaceObject.useRef)();
    var funcRef = (0,external_React_namespaceObject.useRef)(func);
    var mounted = (0,external_React_namespaceObject.useRef)(true);
    funcRef.current = func;
    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
    var useRAF = !wait && wait !== 0 && typeof window !== 'undefined';
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    wait = +wait || 0;
    options = options || {};
    var leading = !!options.leading;
    var trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default
    var maxing = 'maxWait' in options;
    var maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;
    (0,external_React_namespaceObject.useEffect)(function () {
        mounted.current = true;
        return function () {
            mounted.current = false;
        };
    }, []);
    // You may have a question, why we have so many code under the useMemo definition.
    //
    // This was made as we want to escape from useCallback hell and
    // not to initialize a number of functions each time useDebouncedCallback is called.
    //
    // It means that we have less garbage for our GC calls which improves performance.
    // Also, it makes this library smaller.
    //
    // And the last reason, that the code without lots of useCallback with deps is easier to read.
    // You have only one place for that.
    var debounced = (0,external_React_namespaceObject.useMemo)(function () {
        var invokeFunc = function (time) {
            var args = lastArgs.current;
            var thisArg = lastThis.current;
            lastArgs.current = lastThis.current = null;
            lastInvokeTime.current = time;
            return (result.current = funcRef.current.apply(thisArg, args));
        };
        var startTimer = function (pendingFunc, wait) {
            if (useRAF)
                cancelAnimationFrame(timerId.current);
            timerId.current = useRAF ? requestAnimationFrame(pendingFunc) : setTimeout(pendingFunc, wait);
        };
        var shouldInvoke = function (time) {
            if (!mounted.current)
                return false;
            var timeSinceLastCall = time - lastCallTime.current;
            var timeSinceLastInvoke = time - lastInvokeTime.current;
            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (!lastCallTime.current ||
                timeSinceLastCall >= wait ||
                timeSinceLastCall < 0 ||
                (maxing && timeSinceLastInvoke >= maxWait));
        };
        var trailingEdge = function (time) {
            timerId.current = null;
            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs.current) {
                return invokeFunc(time);
            }
            lastArgs.current = lastThis.current = null;
            return result.current;
        };
        var timerExpired = function () {
            var time = Date.now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            // https://github.com/xnimorz/use-debounce/issues/97
            if (!mounted.current) {
                return;
            }
            // Remaining wait calculation
            var timeSinceLastCall = time - lastCallTime.current;
            var timeSinceLastInvoke = time - lastInvokeTime.current;
            var timeWaiting = wait - timeSinceLastCall;
            var remainingWait = maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            // Restart the timer
            startTimer(timerExpired, remainingWait);
        };
        var func = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var time = Date.now();
            var isInvoking = shouldInvoke(time);
            lastArgs.current = args;
            lastThis.current = _this;
            lastCallTime.current = time;
            if (isInvoking) {
                if (!timerId.current && mounted.current) {
                    // Reset any `maxWait` timer.
                    lastInvokeTime.current = lastCallTime.current;
                    // Start the timer for the trailing edge.
                    startTimer(timerExpired, wait);
                    // Invoke the leading edge.
                    return leading ? invokeFunc(lastCallTime.current) : result.current;
                }
                if (maxing) {
                    // Handle invocations in a tight loop.
                    startTimer(timerExpired, wait);
                    return invokeFunc(lastCallTime.current);
                }
            }
            if (!timerId.current) {
                startTimer(timerExpired, wait);
            }
            return result.current;
        };
        func.cancel = function () {
            if (timerId.current) {
                useRAF ? cancelAnimationFrame(timerId.current) : clearTimeout(timerId.current);
            }
            lastInvokeTime.current = 0;
            lastArgs.current = lastCallTime.current = lastThis.current = timerId.current = null;
        };
        func.isPending = function () {
            return !!timerId.current;
        };
        func.flush = function () {
            return !timerId.current ? result.current : trailingEdge(Date.now());
        };
        return func;
    }, [leading, maxing, wait, maxWait, trailing, useRAF]);
    return debounced;
}

;// CONCATENATED MODULE: ./node_modules/react-colorful/dist/index.module.js
function l(){return(l=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}function u(e,r){if(null==e)return{};var t,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r.indexOf(t=a[o])>=0||(n[t]=e[t]);return n}var c="undefined"!=typeof window?external_React_namespaceObject.useLayoutEffect:external_React_namespaceObject.useEffect;function i(e){var r=(0,external_React_namespaceObject.useRef)(e);return (0,external_React_namespaceObject.useEffect)(function(){r.current=e}),(0,external_React_namespaceObject.useCallback)(function(e){return r.current&&r.current(e)},[])}var s,f=function(e,r,t){return void 0===r&&(r=0),void 0===t&&(t=1),e>t?t:e<r?r:e},v=function(e){return"touches"in e},d=function(e,r){var t=e.getBoundingClientRect(),o=v(r)?r.touches[0]:r;return{left:f((o.pageX-(t.left+window.pageXOffset))/t.width),top:f((o.pageY-(t.top+window.pageYOffset))/t.height)}},h=external_React_default().memo(function(r){var t=r.onMove,s=r.onKey,f=u(r,["onMove","onKey"]),h=(0,external_React_namespaceObject.useRef)(null),m=(0,external_React_namespaceObject.useRef)(!1),g=(0,external_React_namespaceObject.useState)(!1),p=g[0],b=g[1],_=i(t),C=i(s),E=(0,external_React_namespaceObject.useCallback)(function(e){e.preventDefault(),(v(e)?e.touches.length>0:e.buttons>0)&&h.current?_(d(h.current,e)):b(!1)},[_]),x=(0,external_React_namespaceObject.useCallback)(function(e){var r=e.nativeEvent;r.preventDefault(),function(e){return!(m.current&&!v(e)||(m.current||(m.current=v(e)),0))}(r)&&(_(d(h.current,r)),b(!0))},[_]),H=(0,external_React_namespaceObject.useCallback)(function(e){var r=e.which||e.keyCode;r<37||r>40||(e.preventDefault(),C({left:39===r?.05:37===r?-.05:0,top:40===r?.05:38===r?-.05:0}))},[C]),N=(0,external_React_namespaceObject.useCallback)(function(){return b(!1)},[]),w=(0,external_React_namespaceObject.useCallback)(function(e){var r=e?window.addEventListener:window.removeEventListener;r(m.current?"touchmove":"mousemove",E),r(m.current?"touchend":"mouseup",N)},[E,N]);return c(function(){return w(p),function(){p&&w(!1)}},[p,w]),external_React_default().createElement("div",l({},f,{className:"react-colorful__interactive",ref:h,onTouchStart:x,onMouseDown:x,onKeyDown:H,tabIndex:0,role:"slider"}))}),m=function(e){return e.filter(Boolean).join(" ")},g=function(r){var t=r.color,o=r.left,n=r.top,a=void 0===n?.5:n,l=m(["react-colorful__pointer",r.className]);return external_React_default().createElement("div",{className:l,style:{top:100*a+"%",left:100*o+"%"}},external_React_default().createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:t}}))},p=function(e,r,t){return void 0===r&&(r=0),void 0===t&&(t=Math.pow(10,r)),Math.round(t*e)/t},b=function(e){return"#"===e[0]&&(e=e.substr(1)),e.length<6?{r:parseInt(e[0]+e[0],16),g:parseInt(e[1]+e[1],16),b:parseInt(e[2]+e[2],16),a:1}:{r:parseInt(e.substr(0,2),16),g:parseInt(e.substr(2,2),16),b:parseInt(e.substr(4,2),16),a:1}},index_module_=function(e){var r=/hsla?\((\d+\.?\d*),\s*(\d+\.?\d*)%?,\s*(\d+\.?\d*)%?,?\s*(\d+\.?\d*)?\)/.exec(e);return r?E({h:Number(r[1]),s:Number(r[2]),l:Number(r[3]),a:void 0===r[4]?1:Number(r[4])}):{h:0,s:0,v:0,a:1}},C=index_module_,E=function(e){var r=e.s,t=e.l;return{h:e.h,s:(r*=(t<50?t:100-t)/100)>0?2*r/(t+r)*100:0,v:t+r,a:e.a}},x=function(e){var r=e.s,t=e.v,o=e.a,n=(200-r)*t/100;return{h:p(e.h),s:p(n>0&&n<200?r*t/100/(n<=100?n:200-n)*100:0),l:p(n/2),a:p(o,2)}},H=function(e){var r=x(e);return"hsl("+r.h+", "+r.s+"%, "+r.l+"%)"},N=function(e){var r=x(e);return"hsla("+r.h+", "+r.s+"%, "+r.l+"%, "+r.a+")"},w=function(e){var r=e.h,t=e.s,o=e.v,n=e.a;r=r/360*6,t/=100,o/=100;var a=Math.floor(r),l=o*(1-t),u=o*(1-(r-a)*t),c=o*(1-(1-r+a)*t),i=a%6;return{r:p(255*[o,u,l,l,c,o][i]),g:p(255*[c,o,o,u,l,l][i]),b:p(255*[l,l,c,o,o,u][i]),a:p(n,2)}},M=function(e){var r=/hsva?\((\d+\.?\d*),\s*(\d+\.?\d*)%?,\s*(\d+\.?\d*)%?,?\s*(\d+\.?\d*)?\)/.exec(e);return r?j({h:Number(r[1]),s:Number(r[2]),v:Number(r[3]),a:void 0===r[4]?1:Number(r[4])}):{h:0,s:0,v:0,a:1}},y=M,q=function(e){var r=/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*(\d+\.?\d*)?\)/.exec(e);return r?I({r:Number(r[1]),g:Number(r[2]),b:Number(r[3]),a:void 0===r[4]?1:Number(r[4])}):{h:0,s:0,v:0,a:1}},k=q,O=function(e){var r=e.toString(16);return r.length<2?"0"+r:r},I=function(e){var r=e.r,t=e.g,o=e.b,n=e.a,a=Math.max(r,t,o),l=a-Math.min(r,t,o),u=l?a===r?(t-o)/l:a===t?2+(o-r)/l:4+(r-t)/l:0;return{h:p(60*(u<0?u+6:u)),s:p(a?l/a*100:0),v:p(a/255*100),a:n}},j=function(e){return{h:p(e.h),s:p(e.s),v:p(e.v),a:p(e.a,2)}},z=external_React_default().memo(function(r){var t=r.hue,o=r.onChange,n=m(["react-colorful__hue",r.className]);return external_React_default().createElement("div",{className:n},external_React_default().createElement(h,{onMove:function(e){o({h:360*e.left})},onKey:function(e){o({h:f(t+360*e.left,0,360)})},"aria-label":"Hue","aria-valuetext":p(t)},external_React_default().createElement(g,{className:"react-colorful__hue-pointer",left:t/360,color:H({h:t,s:100,v:100,a:1})})))}),B=external_React_default().memo(function(r){var t=r.hsva,o=r.onChange,n={backgroundColor:H({h:t.h,s:100,v:100,a:1})};return external_React_default().createElement("div",{className:"react-colorful__saturation",style:n},external_React_default().createElement(h,{onMove:function(e){o({s:100*e.left,v:100-100*e.top})},onKey:function(e){o({s:f(t.s+100*e.left,0,100),v:f(t.v-100*e.top,0,100)})},"aria-label":"Color","aria-valuetext":"Saturation "+p(t.s)+"%, Brightness "+p(t.v)+"%"},external_React_default().createElement(g,{className:"react-colorful__saturation-pointer",top:1-t.v/100,left:t.s/100,color:H(t)})))}),K=function(e,r){if(e===r)return!0;for(var t in e)if(e[t]!==r[t])return!1;return!0},A=function(e,r){return e.replace(/\s/g,"")===r.replace(/\s/g,"")};function D(e,r,l){var u=i(l),c=(0,external_React_namespaceObject.useState)(function(){return e.toHsva(r)}),s=c[0],f=c[1],v=(0,external_React_namespaceObject.useRef)({color:r,hsva:s});(0,external_React_namespaceObject.useEffect)(function(){if(!e.equal(r,v.current.color)){var t=e.toHsva(r);v.current={hsva:t,color:r},f(t)}},[r,e]),(0,external_React_namespaceObject.useEffect)(function(){var r;K(s,v.current.hsva)||e.equal(r=e.fromHsva(s),v.current.color)||(v.current={hsva:s,color:r},u(r))},[s,e,u]);var d=(0,external_React_namespaceObject.useCallback)(function(e){f(function(r){return Object.assign({},r,e)})},[]);return[s,d]}var L,F=function(){return s||( true?__webpack_require__.nc:0)},S=function(e){s=e},T=function(){c(function(){if("undefined"!=typeof document&&!L){(L=document.createElement("style")).innerHTML='.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}';var e=F();e&&L.setAttribute("nonce",e),document.head.appendChild(L)}},[])},X=function(r){var t=r.className,o=r.colorModel,n=r.color,a=void 0===n?o.defaultColor:n,c=r.onChange,i=u(r,["className","colorModel","color","onChange"]);T();var s=D(o,a,c),f=s[0],v=s[1],d=m(["react-colorful",t]);return external_React_default().createElement("div",l({},i,{className:d}),external_React_default().createElement(B,{hsva:f,onChange:v}),external_React_default().createElement(z,{hue:f.h,onChange:v,className:"react-colorful__last-control"}))},Y={defaultColor:"000",toHsva:function(e){return I(b(e))},fromHsva:function(e){return t=(r=w(e)).g,o=r.b,"#"+O(r.r)+O(t)+O(o);var r,t,o},equal:function(e,r){return e.toLowerCase()===r.toLowerCase()||K(b(e),b(r))}},index_module_$=function(r){return external_React_default().createElement(X,l({},r,{colorModel:Y}))},P=function(r){var t=r.className,o=r.hsva,n=r.onChange,a={backgroundImage:"linear-gradient(90deg, "+N(Object.assign({},o,{a:0}))+", "+N(Object.assign({},o,{a:1}))+")"},l=m(["react-colorful__alpha",t]);return e.createElement("div",{className:l},e.createElement("div",{className:"react-colorful__alpha-gradient",style:a}),e.createElement(h,{onMove:function(e){n({a:e.left})},onKey:function(e){n({a:f(o.a+e.left)})},"aria-label":"Alpha","aria-valuetext":p(100*o.a)+"%"},e.createElement(g,{className:"react-colorful__alpha-pointer",left:o.a,color:N(o)})))},R=function(r){var t=r.className,o=r.colorModel,n=r.color,a=void 0===n?o.defaultColor:n,c=r.onChange,i=u(r,["className","colorModel","color","onChange"]);T();var s=D(o,a,c),f=s[0],v=s[1],d=m(["react-colorful",t]);return e.createElement("div",l({},i,{className:d}),e.createElement(B,{hsva:f,onChange:v}),e.createElement(z,{hue:f.h,onChange:v}),e.createElement(P,{hsva:f,onChange:v,className:"react-colorful__last-control"}))},G={defaultColor:{h:0,s:0,l:0,a:1},toHsva:E,fromHsva:x,equal:K},J=function(r){return e.createElement(R,l({},r,{colorModel:G}))},Q={defaultColor:"hsla(0, 0%, 0%, 1)",toHsva:index_module_,fromHsva:N,equal:A},U=function(r){return e.createElement(R,l({},r,{colorModel:Q}))},V={defaultColor:{h:0,s:0,l:0},toHsva:function(e){return E({h:e.h,s:e.s,l:e.l,a:1})},fromHsva:function(e){return{h:(r=x(e)).h,s:r.s,l:r.l};var r},equal:K},W=function(r){return e.createElement(X,l({},r,{colorModel:V}))},Z={defaultColor:"hsl(0, 0%, 0%)",toHsva:C,fromHsva:H,equal:A},ee=function(r){return e.createElement(X,l({},r,{colorModel:Z}))},re={defaultColor:{h:0,s:0,v:0,a:1},toHsva:function(e){return e},fromHsva:j,equal:K},te=function(r){return e.createElement(R,l({},r,{colorModel:re}))},oe={defaultColor:"hsva(0, 0%, 0%, 1)",toHsva:M,fromHsva:function(e){var r=j(e);return"hsva("+r.h+", "+r.s+"%, "+r.v+"%, "+r.a+")"},equal:A},ne=function(r){return e.createElement(R,l({},r,{colorModel:oe}))},ae={defaultColor:{h:0,s:0,v:0},toHsva:function(e){return{h:e.h,s:e.s,v:e.v,a:1}},fromHsva:function(e){var r=j(e);return{h:r.h,s:r.s,v:r.v}},equal:K},le=function(r){return e.createElement(X,l({},r,{colorModel:ae}))},ue={defaultColor:"hsv(0, 0%, 0%)",toHsva:y,fromHsva:function(e){var r=j(e);return"hsv("+r.h+", "+r.s+"%, "+r.v+"%)"},equal:A},ce=function(r){return e.createElement(X,l({},r,{colorModel:ue}))},ie={defaultColor:{r:0,g:0,b:0,a:1},toHsva:I,fromHsva:w,equal:K},se=function(r){return e.createElement(R,l({},r,{colorModel:ie}))},fe={defaultColor:"rgba(0, 0, 0, 1)",toHsva:q,fromHsva:function(e){var r=w(e);return"rgba("+r.r+", "+r.g+", "+r.b+", "+r.a+")"},equal:A},ve=function(r){return e.createElement(R,l({},r,{colorModel:fe}))},de={defaultColor:{r:0,g:0,b:0},toHsva:function(e){return I({r:e.r,g:e.g,b:e.b,a:1})},fromHsva:function(e){return{r:(r=w(e)).r,g:r.g,b:r.b};var r},equal:K},he=function(r){return e.createElement(X,l({},r,{colorModel:de}))},me={defaultColor:"rgb(0, 0, 0)",toHsva:k,fromHsva:function(e){var r=w(e);return"rgb("+r.r+", "+r.g+", "+r.b+")"},equal:A},ge=function(r){return e.createElement(X,l({},r,{colorModel:me}))},pe=/^#?[0-9A-F]{3}$/i,be=/^#?[0-9A-F]{6}$/i,_e=function(e){return be.test(e)||pe.test(e)},Ce=function(e){return e.replace(/([^0-9A-F]+)/gi,"").substr(0,6)},Ee=function(r){var n=r.color,c=void 0===n?"":n,s=r.onChange,f=r.onBlur,v=u(r,["color","onChange","onBlur"]),d=a(function(){return Ce(c)}),h=d[0],m=d[1],g=i(s),p=i(f),b=o(function(e){var r=Ce(e.target.value);m(r),_e(r)&&g("#"+r)},[g]),_=o(function(e){_e(e.target.value)||m(Ce(c)),p(e)},[c,p]);return t(function(){m(Ce(c))},[c]),e.createElement("input",l({},v,{value:h,spellCheck:"false",onChange:b,onBlur:_}))};
//# sourceMappingURL=index.module.js.map

;// CONCATENATED MODULE: ./src/_js/customizer/utils/use-did-update-effect.js


var useDidUpdateEffect = function useDidUpdateEffect(fn, inputs) {
  var didMountRef = (0,external_React_namespaceObject.useRef)(false);
  (0,external_React_namespaceObject.useEffect)(function () {
    if (didMountRef.current) {
      fn();
    } else {
      didMountRef.current = true;
    }
  }, inputs);
};

/* harmony default export */ var use_did_update_effect = (useDidUpdateEffect);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/source-colors/color-picker.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






var ColorPicker = function ColorPicker(props) {
  var hex = props.hex,
      onChange = props.onChange,
      isOpen = props.isOpen;

  var _useState = (0,external_React_namespaceObject.useState)(hex),
      _useState2 = _slicedToArray(_useState, 2),
      color = _useState2[0],
      setColor = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)(hex),
      _useState4 = _slicedToArray(_useState3, 2),
      hexValue = _useState4[0],
      setHexValue = _useState4[1];

  var debouncedOnChange = useDebouncedCallback(onChange, 200);
  use_did_update_effect(function () {
    debouncedOnChange(color);
  }, [color]);
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "c-palette-builder__source-item-color ".concat(isOpen ? 'c-palette-builder__source-item-color--active' : '')
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "c-palette-builder__source-item-preview",
    style: {
      color: color
    }
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "c-palette-builder__source-item-picker",
    onClick: function onClick(event) {
      event.stopPropagation();
    }
  }, /*#__PURE__*/external_React_default().createElement(index_module_$, {
    color: color,
    onChange: function onChange(newColor) {
      setHexValue(newColor);
      setColor(newColor);
    }
  }), /*#__PURE__*/external_React_default().createElement("input", {
    type: "text",
    value: hexValue,
    onChange: function onChange(e) {
      var value = e.target.value;
      setHexValue(value);

      if (external_chroma_default().valid(value) && external_chroma_default()(value).alpha() === 1) {
        setColor(external_chroma_default()(value).hex());
      }
    }
  })));
};
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/contextual-menu/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/utils/use-outside-click.js

/**
 * Hook that alerts clicks outside of the passed ref
 */

function useOutsideClick(ref, callback) {
  (0,external_React_namespaceObject.useEffect)(function () {
    /**
     * Alert if clicked on outside of element
     */
    function handleClickOutside(event) {
      if (ref.current && !ref.current.contains(event.target)) {
        callback();
      }
    } // Bind the event listener


    document.addEventListener("mousedown", handleClickOutside);
    return function () {
      // Unbind the event listener on clean up
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [ref]);
}

/* harmony default export */ var use_outside_click = (useOutsideClick);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/contextual-menu/index.js
function contextual_menu_slicedToArray(arr, i) { return contextual_menu_arrayWithHoles(arr) || contextual_menu_iterableToArrayLimit(arr, i) || contextual_menu_unsupportedIterableToArray(arr, i) || contextual_menu_nonIterableRest(); }

function contextual_menu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function contextual_menu_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return contextual_menu_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return contextual_menu_arrayLikeToArray(o, minLen); }

function contextual_menu_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function contextual_menu_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function contextual_menu_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





var ContextualMenu = function ContextualMenu(props) {
  var actions = props.actions;

  var _useState = (0,external_React_namespaceObject.useState)(false),
      _useState2 = contextual_menu_slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var onToggle = typeof props.onToggle === 'function' ? props.onToggle : function (isOpen) {};
  var onClick = typeof props.onClick === 'function' ? props.onClick : function (event) {
    event.stopPropagation();
  };
  (0,external_React_namespaceObject.useEffect)(function () {
    onToggle(isOpen);
  }, [isOpen]);
  var ref = (0,external_React_namespaceObject.useRef)(null);
  use_outside_click(ref, function () {
    setIsOpen(false);
  });
  return /*#__PURE__*/external_React_default().createElement("div", {
    onClick: onClick,
    ref: ref,
    className: "c-contextual-menu c-contextual-menu--".concat(isOpen ? 'visible' : 'hidden')
  }, /*#__PURE__*/external_React_default().createElement("button", {
    className: "c-contextual-menu__toggle",
    onClick: function onClick(e) {
      e.preventDefault();
      setIsOpen(!isOpen);
    }
  }, /*#__PURE__*/external_React_default().createElement("span", null, "Toggle Menu")), /*#__PURE__*/external_React_default().createElement("div", {
    className: "c-contextual-menu__list"
  }, actions.map(function (_ref, index) {
    var label = _ref.label,
        callback = _ref.callback,
        className = _ref.className;

    var onClick = function onClick(e) {
      e.preventDefault();
      setIsOpen(false);
      callback();
    };

    return /*#__PURE__*/external_React_default().createElement("div", {
      key: index,
      className: "c-contextual-menu__list-item ".concat(className),
      onClick: onClick
    }, label);
  })));
};


;// CONCATENATED MODULE: ./src/_js/customizer/colors/context.js

var ConfigContext = /*#__PURE__*/(0,external_React_namespaceObject.createContext)();
/* harmony default export */ var context = (ConfigContext);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/source-colors/utils.js
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var deepCopy = function deepCopy(object) {
  return JSON.parse(JSON.stringify(object));
};

var getNewColorHex = function getNewColorHex() {
  return '#111111';
};
var getNewColor = function getNewColor() {
  var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    uid: "color_".concat(new Date().getTime()),
    showPicker: true,
    label: label,
    value: getNewColorHex()
  };
};
var getNewColorGroup = function getNewColorGroup() {
  return {
    uid: "color_group_".concat(new Date().getTime()),
    sources: [getNewColor(styleManager.l10n.colorPalettes.sourceColorsDefaultLabel)]
  };
};
var addNewColorGroup = function addNewColorGroup(config) {
  var groupIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var newConfig = deepCopy(config).map(function (group) {
    return _objectSpread(_objectSpread({}, group), {}, {
      sources: group.sources.map(function (color) {
        var showPicker = color.showPicker,
            otherProps = _objectWithoutProperties(color, ["showPicker"]);

        return otherProps;
      })
    });
  });
  newConfig.splice(groupIndex + 1, 0, getNewColorGroup());
  return newConfig;
};
var addNewColorToGroup = function addNewColorToGroup(config, groupIndex, index) {
  var newConfig = deepCopy(config);
  newConfig[groupIndex].sources.splice(index + 1, 0, getNewColor(styleManager.l10n.colorPalettes.sourceColorsDefaultLabel));
  return newConfig;
};
var deleteColor = function deleteColor(config, groupIndex, index) {
  var newConfig = deepCopy(config);
  newConfig[groupIndex].sources.splice(index, 1);

  if (!newConfig[groupIndex].sources.length) {
    newConfig.splice(groupIndex, 1);
  }

  return newConfig;
};
var updateColor = function updateColor(config, groupIndex, index, newValue) {
  var newConfig = deepCopy(config);
  newConfig[groupIndex].sources[index] = Object.assign({}, newConfig[groupIndex].sources[index], newValue);
  return newConfig;
};
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/source-colors/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/source-colors/index.js
function source_colors_slicedToArray(arr, i) { return source_colors_arrayWithHoles(arr) || source_colors_iterableToArrayLimit(arr, i) || source_colors_unsupportedIterableToArray(arr, i) || source_colors_nonIterableRest(); }

function source_colors_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function source_colors_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return source_colors_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return source_colors_arrayLikeToArray(o, minLen); }

function source_colors_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function source_colors_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function source_colors_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }









var SourceColors = function SourceColors(props) {
  var _useContext = (0,external_React_namespaceObject.useContext)(context),
      config = _useContext.config,
      setConfig = _useContext.setConfig;

  (0,external_React_namespaceObject.useEffect)(function () {
    if (!config.length) {
      setConfig(addNewColorGroup(config));
      return;
    }

    if (!config.filter(function (group) {
      return !!group.sources.length;
    }).length) {
      setConfig([]);
    }
  }, [config]);
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "c-palette-builder__source-list"
  }, config.map(function (group, groupIndex) {
    return /*#__PURE__*/external_React_default().createElement(SourceColorsGroup, {
      key: group.uid,
      sources: group.sources,
      index: groupIndex
    });
  }));
};

var SourceColorsGroup = function SourceColorsGroup(props) {
  var uid = props.uid,
      sources = props.sources;
  var groupIndex = props.index;
  var style = {
    '--sm-source-main-color': sources[0].value
  };
  return /*#__PURE__*/external_React_default().createElement("div", {
    key: uid,
    className: "c-palette-builder__source-group",
    style: style
  }, sources.map(function (color, index) {
    return /*#__PURE__*/external_React_default().createElement(SourceColorControl, {
      key: color.uid,
      groupIndex: groupIndex,
      index: index,
      color: color,
      showPicker: color.showPicker
    });
  }));
};

var SourceColorControl = function SourceColorControl(props) {
  var color = props.color,
      index = props.index,
      groupIndex = props.groupIndex;

  var _useState = (0,external_React_namespaceObject.useState)(false),
      _useState2 = source_colors_slicedToArray(_useState, 2),
      active = _useState2[0],
      setActive = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)(false),
      _useState4 = source_colors_slicedToArray(_useState3, 2),
      hover = _useState4[0],
      setHover = _useState4[1];

  var _useState5 = (0,external_React_namespaceObject.useState)(false),
      _useState6 = source_colors_slicedToArray(_useState5, 2),
      menuIsOpen = _useState6[0],
      setMenuIsOpen = _useState6[1];

  var _useState7 = (0,external_React_namespaceObject.useState)(false),
      _useState8 = source_colors_slicedToArray(_useState7, 2),
      editable = _useState8[0],
      setEditable = _useState8[1];

  var _useState9 = (0,external_React_namespaceObject.useState)(),
      _useState10 = source_colors_slicedToArray(_useState9, 2),
      showPicker = _useState10[0],
      setShowPicker = _useState10[1];

  var _useContext2 = (0,external_React_namespaceObject.useContext)(context),
      config = _useContext2.config,
      setConfig = _useContext2.setConfig,
      resetActivePreset = _useContext2.resetActivePreset;

  var _onChange = (0,external_React_namespaceObject.useCallback)(function (color) {
    var newConfig = updateColor(config, groupIndex, index, color);
    setConfig(newConfig);
    resetActivePreset();
  }, [config, groupIndex, index]);

  var interpolateColor = (0,external_React_namespaceObject.useCallback)(function () {
    setConfig(addNewColorToGroup(config, groupIndex, index));
    resetActivePreset();
  }, [config, groupIndex, index]);
  var addColor = (0,external_React_namespaceObject.useCallback)(function () {
    setConfig(addNewColorGroup(config, groupIndex));
    resetActivePreset();
  }, [config, groupIndex]);
  var renameColor = (0,external_React_namespaceObject.useCallback)(function () {
    setEditable(true);
  }, []);
  var removeColor = (0,external_React_namespaceObject.useCallback)(function () {
    setConfig(deleteColor(config, groupIndex, index));
    resetActivePreset();
  }, [config, groupIndex, index]);
  var actions = [{
    label: 'Interpolate Color',
    callback: interpolateColor
  }, {
    label: 'Add Color',
    callback: addColor
  }, {
    label: 'Rename Color',
    callback: renameColor
  }, {
    label: 'Remove Color',
    callback: removeColor,
    className: 'c-contextual-menu__list-item--danger'
  }];
  var inputRef = (0,external_React_namespaceObject.useRef)(null);
  var pickerRef = (0,external_React_namespaceObject.useRef)(null);
  use_outside_click(pickerRef, function () {
    setShowPicker(false);
  }); // delay setting showPicker with one render cycle in order to show fadein animation

  (0,external_React_namespaceObject.useEffect)(function () {
    if (typeof showPicker === "undefined" && typeof props.showPicker !== "undefined") {
      setShowPicker(props.showPicker);
    }
  }, [showPicker]);
  (0,external_React_namespaceObject.useEffect)(function () {
    setActive(hover || menuIsOpen);
  }, [hover, menuIsOpen]);
  (0,external_React_namespaceObject.useEffect)(function () {
    if (editable) {
      inputRef.current.focus();
    }
  }, [editable]);

  var onLabelBlur = function onLabelBlur(e) {
    setEditable(false);
  };

  return /*#__PURE__*/external_React_default().createElement("div", {
    onMouseEnter: function onMouseEnter() {
      setHover(true);
    },
    onMouseLeave: function onMouseLeave() {
      setHover(false);
    },
    onClick: function onClick() {
      setShowPicker(!showPicker);
    },
    ref: pickerRef,
    className: "c-palette-builder__source-item ".concat(active ? 'c-palette-builder__source-item--active' : '')
  }, /*#__PURE__*/external_React_default().createElement(ColorPicker, {
    hex: color.value,
    onChange: function onChange(hex) {
      _onChange({
        value: hex
      });
    },
    isOpen: showPicker
  }), !editable && /*#__PURE__*/external_React_default().createElement("div", {
    className: "c-palette-builder__source-item-label"
  }, color.label), editable && /*#__PURE__*/external_React_default().createElement("input", {
    type: "text",
    ref: inputRef,
    value: color.label,
    className: "c-palette-builder__source-item-label",
    onChange: function onChange(e) {
      _onChange({
        label: e.target.value
      });
    },
    onBlur: onLabelBlur
  }), /*#__PURE__*/external_React_default().createElement(ContextualMenu, {
    actions: actions,
    onToggle: setMenuIsOpen,
    onClick: function onClick(event) {
      event.stopPropagation();
      setShowPicker(false);
    }
  }));
};


// EXTERNAL MODULE: ./node_modules/hsluv/hsluv.js
var hsluv = __webpack_require__(119);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/builder/utils/contrast-array.js
var optimalContrastArray = Array.from(Array(12)).map(function (x, i) {
  return Math.pow(21, i / 11);
}); //	https://medium.com/envoy-design/designing-an-accessible-color-scheme-again-fd35cfa9d796

var contrastRangesArray = [[1, 1], [1.07, 1.17], [1.21, 1.31], [1.5, 1.91], [2.1, 2.63], [3, 3.5], [4.51, 4.67], [6, 7], [8.75, 10.5], [11.67, 15], [16.15, 19.1], [21, 21]]; // powers of 21 ^ 1/10 but with small adjustments for the lighter colors

var myOptimalContrastArray = [1, 1.07, // 1.32
1.25, // 1.74
1.8, // 2.29
2.63, // 3.03
3.99, 5.26, 6.94, 9.15, 12.07, // fg1
15.92, // fg2
19 // almost black (21)
];
var myOptimalContrastArray2 = (/* unused pure expression or super */ null && ([1, // 21 ^ 0
1.079, // 21 ^ 0.025
1.35588, // 21 ^ 0.1
1.83841, // 21 ^ 0.2
2.49267, // 21 ^ 0.3
3.37977, // 21 ^ 0.4
4.58257, // 21 ^ 0.5
6.21343, // 21 ^ 0.6
8.42468, // 21 ^ 0.7
11.42287, // 21 ^ 0.8
15.48807, // 21 ^ 0.9
19.4609 // 21 ^ 0.975
//  21, // 21 ^ 1
]));
var mathematicArray = (/* unused pure expression or super */ null && ([1, 1.1, 1.25, 1.5275, 2.3332, 3, // AA
4.5825, // AA
7, // AAA
9, 13.7475, 16.8, 19 //  21,
]));
var minContrastArray = contrastRangesArray.map(function (x) {
  return x[0];
});
var maxContrastArray = contrastRangesArray.map(function (x) {
  return x[1];
});
/* harmony default export */ var contrast_array = (myOptimalContrastArray);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/builder/utils/get-palettes-from-colors.js
function get_palettes_from_colors_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function get_palettes_from_colors_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { get_palettes_from_colors_ownKeys(Object(source), true).forEach(function (key) { get_palettes_from_colors_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { get_palettes_from_colors_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function get_palettes_from_colors_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var getPalettesFromColors = function getPalettesFromColors(colorGroups) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    correctLightness: true,
    useSources: true,
    mode: 'lch',
    bezierInterpolation: false
  };
  var functionalColors = getFunctionalColors(colorGroups);
  var palettes = colorGroups.map(mapColorToPalette(attributes));
  var functionalPalettes = functionalColors.map(mapColorToPalette(attributes));
  var allPalettes = palettes.concat(functionalPalettes);
  return mapSanitizePalettes(allPalettes, attributes);
};

var get_palettes_from_colors_noop = function noop(palette) {
  return palette;
};

var mapSanitizePalettes = function mapSanitizePalettes(colors) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return colors.map(mapCorrectLightness(attributes)).map(mapUpdateProps).map(mapUseSource(attributes)).map(mapAddSourceIndex(attributes)).map(mapAddTextColors);
};

var mapAddTextColors = function mapAddTextColors(palette) {
  palette.textColors = palette.colors.slice(9, 11).map(function (color, index) {
    return get_palettes_from_colors_objectSpread(get_palettes_from_colors_objectSpread({}, color), {}, {
      value: getTextColor(color.value, 9 + index)
    });
  });
  return palette;
};

var mapAddSourceIndex = function mapAddSourceIndex(attributes) {
  return function (palette, index, palettes) {
    var source = palette.source,
        colors = palette.colors;
    var sourceIndex = getSourceIndex(palette); // falback sourceIndex when the source isn't used in the palette

    if (!sourceIndex > -1) {
      sourceIndex = getBestPositionInPalette(source[0], colors.map(function (color) {
        return color.value;
      }), attributes);
    }

    return get_palettes_from_colors_objectSpread({
      sourceIndex: sourceIndex
    }, palette);
  };
};

var mapColorToPalette = function mapColorToPalette(attributes) {
  return function (groupObject, index) {
    var colorObjects = groupObject.sources;
    var sources = colorObjects.map(function (colorObj) {
      return colorObj.value;
    });
    var colors = createAutoPalette(sources, attributes);
    var _colorObjects$ = colorObjects[0],
        label = _colorObjects$.label,
        id = _colorObjects$.id;
    return {
      id: id || index + 1,
      lightColorsCount: 5,
      label: label,
      source: sources,
      colors: colors
    };
  };
};

var mapCorrectLightness = function mapCorrectLightness(_ref) {
  var correctLightness = _ref.correctLightness,
      mode = _ref.mode;

  if (!correctLightness) {
    return get_palettes_from_colors_noop;
  }

  return function (palette) {
    palette.colors = palette.colors.map(function (color, index) {
      var luminance = contrastToLuminance(contrast_array[index]);
      return external_chroma_default()(color).luminance(luminance, 'rgb').hex();
    });
    return palette;
  };
};

var mapUpdateProps = function mapUpdateProps(palette) {
  palette.colors = palette.colors.map(function (color, index) {
    return Object.assign({}, {
      value: color
    });
  });
  return palette;
};

var mapUseSource = function mapUseSource(attributes) {
  var useSources = attributes.useSources;

  if (!useSources) {
    return get_palettes_from_colors_noop;
  }

  return function (palette) {
    var source = palette.source;
    var position = getBestPositionInPalette(source[0], palette.colors.map(function (color) {
      return color.value;
    }), attributes);
    palette.colors.splice(position, 1, {
      value: source[0],
      isSource: true
    });
    return palette;
  };
};

var getSourceIndex = function getSourceIndex(palette) {
  return palette.colors.findIndex(function (color) {
    return color.value === palette.source;
  });
};

var getBestPositionInPalette = function getBestPositionInPalette(color, colors, attributes, byColorDistance) {
  var min = Number.MAX_SAFE_INTEGER;
  var pos = -1;

  for (var i = 0; i < colors.length - 1; i++) {
    var distance = void 0;

    if (!!byColorDistance) {
      distance = external_chroma_default().distance(colors[i], color, 'rgb');
    } else {
      distance = Math.abs(external_chroma_default()(colors[i]).luminance() - external_chroma_default()(color).luminance());
    }

    if (distance < min) {
      min = distance;
      pos = i;
    }
  }

  var firstDarkPos = Math.ceil(colors.length / 2); // if we want to preserve contrast we should do this

  if (attributes !== null && attributes !== void 0 && attributes.correctLightness) {
    if (external_chroma_default().contrast(color, 'white') > Math.sqrt(21)) {
      pos = Math.max(firstDarkPos, pos);
    } else {
      pos = Math.min(firstDarkPos - 1, pos);
    }
  }

  return pos;
};

var getTextColor = function getTextColor(hex, position) {
  var luminance = contrastToLuminance(contrast_array[position]);
  var hpluv = (0,hsluv.hexToHpluv)(hex);
  var h = Math.min(Math.max(hpluv[0], 0), 360);
  var p = Math.min(Math.max(hpluv[1], 0), 100);
  var l = Math.min(Math.max(hpluv[2], 0), 100);
  var rgb = (0,hsluv.hpluvToRgb)([h, p, l]).map(function (x) {
    return x * 255;
  });
  return external_chroma_default()(rgb).luminance(luminance).hex();
};

var contrastToLuminance = function contrastToLuminance(contrast) {
  return 1.05 / contrast - 0.05;
};

var createAutoPalette = function createAutoPalette(colors) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var mode = attributes.mode,
      bezierInterpolation = attributes.bezierInterpolation;
  var newColors = colors.slice();
  newColors.splice(0, 0, '#FFFFFF');
  newColors.push('#000000');
  newColors.sort(function (c1, c2) {
    return external_chroma_default()(c1).luminance() > external_chroma_default()(c2).luminance() ? -1 : 1;
  });

  if (!!bezierInterpolation) {
    return external_chroma_default().bezier(newColors).scale().mode(mode).correctLightness().colors(12);
  } else {
    return external_chroma_default().scale(newColors).mode(mode).correctLightness().colors(12);
  }
};

var blend = function blend(functionalColor, brandColor) {
  var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var l1 = external_chroma_default()(functionalColor).get('hsl.s');
  var l2 = external_chroma_default()(brandColor).get('hsl.s');
  var l3 = l1 * (1 - 0.8 * ratio) + l2 * 0.8 * ratio;
  return external_chroma_default()(functionalColor).mix(brandColor, 0.1 * ratio).set('hsl.s', l3).hex();
};

var getFunctionalColors = function getFunctionalColors(colorGroups) {
  var _colorGroups$, _colorGroups$$sources;

  if (!(colorGroups !== null && colorGroups !== void 0 && colorGroups.length) || !((_colorGroups$ = colorGroups[0]) !== null && _colorGroups$ !== void 0 && (_colorGroups$$sources = _colorGroups$.sources) !== null && _colorGroups$$sources !== void 0 && _colorGroups$$sources.length)) {
    return [];
  }

  var color = colorGroups[0].sources[0].value;
  var blue = blend('#2E72D2', color);
  var red = blend('#D82C0D', color);
  var yellow = blend('#FFCC00', color, 0.5);
  var green = blend('#00703c', color, 0.75);
  return [{
    sources: [{
      value: blue,
      label: 'Info',
      id: '_info'
    }]
  }, {
    sources: [{
      value: red,
      label: 'Error',
      id: '_error'
    }]
  }, {
    sources: [{
      value: yellow,
      label: 'Warning',
      id: '_warning'
    }]
  }, {
    sources: [{
      value: green,
      label: 'Success',
      id: '_success'
    }]
  }];
};
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/palette-list/get-random-stripes.js
var getRandomBetween = function getRandomBetween(min, max) {
  var random = Math.max(0, Math.random() - Number.MIN_VALUE);
  return Math.floor(random * (max - min + 1) + min);
};

var getRandomStripes = function getRandomStripes(palettes) {
  var widths = [1, 1, 2, 2, 4];

  if (!palettes.length) {
    return [];
  }

  var stripes = Array.from(Array(5).keys()).map(function (idx) {
    var stripe = document.createElement('div');
    var widthPos = getRandomBetween(0, widths.length - 1);
    var width = widths[widthPos];
    widths.splice(widthPos, 1);
    return {
      index: idx,
      element: stripe,
      width: width
    };
  });
  stripes.sort(function (a, b) {
    return a.width > b.width ? -1 : 1;
  });
  var segments = [Array.from(Array(10).keys())];
  stripes.forEach(function (stripe) {
    var segmentsIndexes = Array.from(Array(segments.length).keys());
    var availSegmentsIndexes = segmentsIndexes.filter(function (index) {
      return segments[index].length >= stripe.width;
    });
    var segmentRandom = getRandomBetween(0, availSegmentsIndexes.length - 1);
    var segmentIndex = availSegmentsIndexes[segmentRandom];
    var thisSegment = segments[segmentIndex];
    var positionRandom = getRandomBetween(0, thisSegment.length - stripe.width);
    var position = thisSegment[positionRandom];
    segments.splice(segmentIndex, 1, thisSegment.slice(0, positionRandom), thisSegment.slice(positionRandom + stripe.width, thisSegment.length));
    stripe.pos = position;
  });
  var sourceColors = [];
  var otherColors = [];
  palettes.forEach(function (palette) {
    var id = palette.id + '';
    var sourceIndex = palette.sourceIndex;

    if (id.charAt(0) === '_') {
      return;
    }

    sourceColors.push(palette.colors[sourceIndex].value);
    var remainingColors = palette.colors.slice().map(function (color) {
      return color.value;
    });
    remainingColors.splice(sourceIndex, 1);
    otherColors = otherColors.concat(remainingColors);
  }); // Randomize order of generated colors

  otherColors.sort(function () {
    return Math.random() > 0.5 ? -1 : 1;
  }); // merge sources and other colors

  var colors = sourceColors.concat(otherColors).slice(0, 5);
  stripes.sort(function (a, b) {
    return a.width > b.width ? -1 : 1;
  });
  stripes.forEach(function (stripe, index) {
    stripe.color = colors[index];
  });
  stripes.sort(function (a, b) {
    return a.index > b.index ? -1 : 1;
  });
  return stripes;
};

/* harmony default export */ var get_random_stripes = (getRandomStripes);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/palette-list/get-text-color.js
var get_text_color_getTextColor = function getTextColor(palette) {
  var lightColorsCount = palette.lightColorsCount,
      sourceIndex = palette.sourceIndex,
      textColors = palette.textColors;
  return sourceIndex > lightColorsCount ? '#FFFFFF' : textColors[0].value;
};

/* harmony default export */ var get_text_color = (get_text_color_getTextColor);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/palette-list/utils.js
function utils_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function utils_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { utils_ownKeys(Object(source), true).forEach(function (key) { utils_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { utils_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function utils_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = utils_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function utils_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var normalizeCloudPresets = function normalizeCloudPresets(presets) {
  return Object.keys(presets).map(function (key) {
    var _preset$preview;

    var preset = presets[key];
    var colorGroups = preset.color_groups.map(function (group) {
      var _uid = group._uid,
          other = utils_objectWithoutProperties(group, ["_uid"]);

      var sources = group.sources.map(function (source) {
        var color = source.color,
            _uid = source._uid,
            other = utils_objectWithoutProperties(source, ["color", "_uid"]);

        return utils_objectSpread(utils_objectSpread({}, other), {}, {
          uid: _uid,
          value: color
        });
      });
      sources.sort(function (a, b) {
        return a._priority > b._priority ? 1 : -1;
      });
      return utils_objectSpread(utils_objectSpread({}, other), {}, {
        sources: sources,
        uid: _uid
      });
    });
    colorGroups.sort(function (a, b) {
      return a._priority > b._priority ? 1 : -1;
    });
    var palettes = getPalettesFromColors(colorGroups);
    return {
      uid: preset.hashid,
      config: colorGroups,
      stripes: get_random_stripes(palettes),
      textColor: get_text_color(palettes[0]),
      image: preset === null || preset === void 0 ? void 0 : (_preset$preview = preset.preview) === null || _preset$preview === void 0 ? void 0 : _preset$preview.background_image_url,
      quote: preset === null || preset === void 0 ? void 0 : preset.description
    };
  });
};


;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/palette-list/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/palette-list/index.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }




var presets = normalizeCloudPresets(styleManager.colorPalettes.palettes);

var PresetsList = function PresetsList(props) {
  var noop = function noop() {};

  var onChange = props.onChange || noop;
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: 'sm-presets-list'
  }, presets.map(function (preset) {
    return /*#__PURE__*/external_React_default().createElement(PaletteListItem, {
      preset: preset,
      key: preset.uid,
      active: preset.uid === props.active,
      onChange: onChange
    });
  }));
};

var PaletteListItem = function PaletteListItem(props) {
  var preset = props.preset,
      active = props.active;

  var noop = function noop() {};

  var onChange = props.onChange || noop;
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-presets-list__item",
    onClick: function onClick() {
      onChange(preset);
    }
  }, /*#__PURE__*/external_React_default().createElement(PresetPreview, _extends({}, preset, {
    active: active
  })));
};

var PresetPreview = function PresetPreview(props) {
  var textColor = props.textColor,
      stripes = props.stripes,
      quote = props.quote,
      image = props.image,
      active = props.active;
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-presets-preview ".concat(active ? 'sm-presets-preview--active' : ''),
    style: {
      backgroundImage: "url(".concat(image, ")")
    }
  }, quote && /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-presets-preview__quote",
    style: {
      color: textColor
    }
  }, quote), /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-presets-preview__stripes"
  }, stripes.map(function (stripe, index) {
    return /*#__PURE__*/external_React_default().createElement("div", {
      key: index,
      className: "sm-presets-preview__stripe sm-presets-preview__stripe-w".concat(stripe.width, " sm-presets-preview__stripe-p").concat(stripe.pos)
    }, /*#__PURE__*/external_React_default().createElement("div", {
      className: "sm-presets-preview__pixel",
      style: {
        color: stripe.color
      }
    }));
  })));
};
/* harmony default export */ var palette_list = (PresetsList);
;// CONCATENATED MODULE: ./src/_js/customizer/svg/upload.svg


var upload_symbol = new (browser_symbol_default())({
  "id": "upload",
  "use": "upload-usage",
  "viewBox": "0 0 32 41",
  "content": "<symbol viewBox=\"0 0 32 41\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" id=\"upload\">\n<path d=\"M20 0.869141H0V40.8691H32V12.8691L20 0.869141ZM18 26.8691V34.8691H14V26.8691H8L16.02 18.8691L24 26.8691H18ZM18 14.8691V3.86914L29 14.8691H18Z\" fill=\"#0F376A\" />\n</symbol>"
});
var upload_result = browser_sprite_build_default().add(upload_symbol);
/* harmony default export */ var upload = (upload_symbol);
;// CONCATENATED MODULE: ./node_modules/worker-loader/dist/cjs.js!./src/_js/customizer/colors/components/dropzone/worker.js
function Worker_fn() {
  return new Worker(__webpack_require__.p + "worker.js");
}

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/dropzone/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/dropzone/index.js
function dropzone_slicedToArray(arr, i) { return dropzone_arrayWithHoles(arr) || dropzone_iterableToArrayLimit(arr, i) || dropzone_unsupportedIterableToArray(arr, i) || dropzone_nonIterableRest(); }

function dropzone_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dropzone_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dropzone_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dropzone_arrayLikeToArray(o, minLen); }

function dropzone_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function dropzone_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function dropzone_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }










var myWorker = new Worker_fn();

var canInterpolate = function canInterpolate(color1, color2) {
  var luminance1 = external_chroma_default()(color1).luminance();
  var luminance2 = external_chroma_default()(color2).luminance();
  return Math.abs(luminance1 - luminance2) > 0.3;
};

var maybeInterpolateColors = function maybeInterpolateColors(colors) {
  if (colors.length >= 3 && canInterpolate(colors[0], colors[1]) && canInterpolate(colors[0], colors[2]) && canInterpolate(colors[1], colors[2])) {
    return [colors];
  }

  if (colors.length >= 2 && canInterpolate(colors[0], colors[1])) {
    return [[colors[0], colors[1]], [colors[2]]];
  }

  if (colors.length >= 3 && canInterpolate(colors[0], colors[2])) {
    return [[colors[0], colors[2]], [colors[1]]];
  }

  if (colors.length >= 3 && canInterpolate(colors[0], colors[2])) {
    return [[colors[0]], [colors[1], colors[2]]];
  }

  return [[colors[0]], [colors[1]], [colors[2]]];
};

var DropZone = function DropZone() {
  var _useContext = (0,external_React_namespaceObject.useContext)(context),
      setConfig = _useContext.setConfig;

  var _useState = (0,external_React_namespaceObject.useState)(null),
      _useState2 = dropzone_slicedToArray(_useState, 2),
      files = _useState2[0],
      setFiles = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)([]),
      _useState4 = dropzone_slicedToArray(_useState3, 2),
      stripes = _useState4[0],
      setStripes = _useState4[1];

  var imgSourceRef = (0,external_React_namespaceObject.useRef)(null);
  var imgPreviewRef = (0,external_React_namespaceObject.useRef)(null);
  var canvasRef = (0,external_React_namespaceObject.useRef)(null);
  var previewRef = (0,external_React_namespaceObject.useRef)(null);

  var dragOver = function dragOver(e) {
    e.preventDefault();
  };

  var dragEnter = function dragEnter(e) {
    e.preventDefault();
  };

  var dragLeave = function dragLeave(e) {
    e.preventDefault();
  };

  var fileDrop = function fileDrop(e) {
    e.preventDefault();
    var files = e.dataTransfer.files;
    setFiles(files);
  };

  (0,external_React_namespaceObject.useEffect)(function () {
    myWorker.onmessage = function (event) {
      var order = ["primary", "secondary", "tertiary", "quinary", "senary", "septenary", "octonary", "nonary", "denary"];
      var type = event.data.type;

      if ('palette' === type) {
        var groups = maybeInterpolateColors(event.data.colors);
        var config = groups.map(function (colors, groupIndex) {
          var label = "Brand ".concat(order[groupIndex]);

          if (groupIndex === 0) {
            label = label.charAt(0).toUpperCase() + label.slice(1);
          }

          var time = new Date().getTime();
          return {
            uid: "color_group_".concat(time).concat(groupIndex),
            sources: colors.map(function (color, colorIndex) {
              if (colorIndex !== 0) {
                label = styleManager.l10n.colorPalettes.dropzoneInterpolatedColorLabel;
              }

              return {
                uid: "color_".concat(time).concat(groupIndex).concat(colorIndex),
                label: label,
                value: external_chroma_default()(color).hex()
              };
            })
          };
        });
        setConfig(config);
        var preset = {};
        preset.palettes = getPalettesFromColors(config);
        setStripes(get_random_stripes(preset));
      }
    };

    return function () {
      delete myWorker.onmessage;
    };
  }, []);
  (0,external_React_namespaceObject.useEffect)(function () {
    var imgSource = imgSourceRef.current;
    var imgPreview = imgPreviewRef.current; // FileReader support

    if (FileReader && files && files.length) {
      var fr = new FileReader();

      fr.onload = function () {
        imgSource.src = fr.result;
        imgPreview.src = fr.result;
      };

      fr.readAsDataURL(files[0]);
    }
  }, [files]);

  var onImageLoad = function onImageLoad() {
    var imgSource = imgSourceRef.current;
    var canvas = canvasRef.current;
    var context = canvas.getContext('2d');
    canvas.width = Math.min(imgSource.width, 100);
    canvas.height = canvas.width * imgSource.height / imgSource.width;
    context.drawImage(imgSource, 0, 0, canvas.width, canvas.height);
    var imageData = context.getImageData(0, 0, canvas.width, canvas.height).data;
    myWorker.postMessage({
      type: 'image',
      imageData: imageData,
      width: canvas.width,
      height: canvas.height
    });
  };

  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "dropzone"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "customize-control-description"
  }, styleManager.l10n.colorPalettes.dropzoneDesc), /*#__PURE__*/external_React_default().createElement("div", {
    className: "dropzone-container",
    onDragOver: dragOver,
    onDragEnter: dragEnter,
    onDragLeave: dragLeave,
    onDrop: fileDrop
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "dropzone-placeholder"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "dropzone-info"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "dropzone-info-icon",
    dangerouslySetInnerHTML: {
      __html: "\n                <svg viewBox=\"".concat(upload.viewBox, "\">\n                  <use xlink:href=\"#").concat(upload.id, "\" />\n                </svg>")
    }
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "dropzone-info-title"
  }, styleManager.l10n.colorPalettes.dropzoneTitle), /*#__PURE__*/external_React_default().createElement("div", {
    className: "dropzone-info-text",
    dangerouslySetInnerHTML: styleManager.l10n.colorPalettes.dropzoneSubtitle
  }))), /*#__PURE__*/external_React_default().createElement(PresetPreview, {
    stripes: stripes
  }), /*#__PURE__*/external_React_default().createElement("img", {
    alt: "Preview",
    className: "dropzone-image-preview",
    ref: imgPreviewRef
  })), /*#__PURE__*/external_React_default().createElement("img", {
    alt: "Source",
    className: "dropzone-image-source",
    ref: imgSourceRef,
    onLoad: onImageLoad
  }), /*#__PURE__*/external_React_default().createElement("canvas", {
    className: "dropzone-canvas",
    ref: canvasRef
  }));
};

/* harmony default export */ var dropzone = (DropZone);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/accordion/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/accordion/index.js
function accordion_slicedToArray(arr, i) { return accordion_arrayWithHoles(arr) || accordion_iterableToArrayLimit(arr, i) || accordion_unsupportedIterableToArray(arr, i) || accordion_nonIterableRest(); }

function accordion_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function accordion_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return accordion_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return accordion_arrayLikeToArray(o, minLen); }

function accordion_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function accordion_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function accordion_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




var Accordion = function Accordion(props) {
  var sections = external_React_default().Children.toArray(props.children).filter(function (child) {
    return child.type === AccordionSection;
  });
  var open = sections.findIndex(function (section) {
    var _section$props;

    return !!(section !== null && section !== void 0 && (_section$props = section.props) !== null && _section$props !== void 0 && _section$props.open);
  });

  var _useState = (0,external_React_namespaceObject.useState)(open),
      _useState2 = accordion_slicedToArray(_useState, 2),
      active = _useState2[0],
      setActive = _useState2[1];

  return sections.map(function (section, index) {
    var _section$props2 = section.props,
        title = _section$props2.title,
        children = _section$props2.children;
    return /*#__PURE__*/external_React_default().createElement("div", {
      className: "sm-blinds sm-blinds--".concat(active === index ? 'open' : 'closed')
    }, /*#__PURE__*/external_React_default().createElement("div", {
      className: "sm-blinds__header",
      onClick: function onClick() {
        setActive(active !== index ? index : null);
      }
    }, /*#__PURE__*/external_React_default().createElement("div", {
      className: "sm-blinds__title"
    }, title), /*#__PURE__*/external_React_default().createElement("div", {
      className: "sm-blinds__toggle"
    })), /*#__PURE__*/external_React_default().createElement("div", {
      className: "sm-blinds__body"
    }, children));
  });
};

var AccordionSection = function AccordionSection(props) {
  return null;
};


;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/builder/utils/index.js


var getColorsFromInputValue = function getColorsFromInputValue(value) {
  var colors;

  try {
    colors = JSON.parse(value);
  } catch (e) {
    colors = [];
  }

  return colors;
};
var getValueFromColors = function getValueFromColors(colors) {
  return JSON.stringify(colors);
};
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/builder/utils/get-css-from-palettes.js
var getCSSFromPalettes = function getCSSFromPalettes(palettesArray) {
  var variation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var palettes = palettesArray.slice();

  if (!palettes.length) {
    return '';
  } // the old implementation generates 3 fallback palettes and
  // we need to overwrite all 3 of them when the user starts building a new palette
  // @todo this is necessary only in the Customizer preview


  while (palettes.length < 3) {
    palettes.push(palettes[0]);
  }

  return palettes.reduce(function (palettesAcc, palette, paletteIndex, palettes) {
    var id = palette.id,
        sourceIndex = palette.sourceIndex;
    return "\n      ".concat(palettesAcc, "\n      \n      html {\n        ").concat(getInitialColorVaraibles(palette), "\n        ").concat(getVariablesCSS(palette, variation - 1), "\n        ").concat(getVariablesCSS(palette, sourceIndex, false, true), "\n      } \n      \n      .is-dark {\n        ").concat(getVariablesCSS(palette, variation - 1, true), "\n        ").concat(getVariablesCSS(palette, sourceIndex, true, true), "\n      }\n    ");
  }, '');
};

var getVariablesCSS = function getVariablesCSS(palette) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var isDark = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isShifted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var colors = palette.colors;
  var count = colors.length;
  return colors.reduce(function (colorsAcc, color, index) {
    var oldColorIndex = (index + offset) % count;

    if (isDark) {
      if (oldColorIndex < count / 2) {
        oldColorIndex = 11 - oldColorIndex;
      } else {
        return colorsAcc;
      }
    }

    return "".concat(colorsAcc, "\n      ").concat(getColorVariables(palette, index, oldColorIndex, isShifted), "\n    ");
  }, '');
};

var getInitialColorVaraibles = function getInitialColorVaraibles(palette) {
  var colors = palette.colors,
      textColors = palette.textColors,
      id = palette.id;
  var prefix = '--sm-color-palette-';
  var accentColors = colors.reduce(function (colorsAcc, color, index) {
    return "".concat(colorsAcc, "\n      ").concat(prefix).concat(id, "-color-").concat(index + 1, ": ").concat(color.value, ";\n    ");
  }, '');
  var darkColors = textColors.reduce(function (colorsAcc, color, index) {
    return "".concat(colorsAcc, "\n      ").concat(prefix).concat(id, "-text-color-").concat(index + 1, ": ").concat(color.value, ";\n    ");
  }, '');
  return "\n    ".concat(accentColors, "\n    ").concat(darkColors, "\n  ");
};

var getColorVariables = function getColorVariables(palette, newColorIndex, oldColorIndex, isShifted) {
  var colors = palette.colors,
      id = palette.id,
      lightColorsCount = palette.lightColorsCount;
  var count = colors.length;
  var accentColorIndex = (oldColorIndex + count / 2) % count;
  var prefix = '--sm-color-palette-';
  var suffix = isShifted ? '-shifted' : '';
  var newIndex = parseInt(newColorIndex, 10) + 1;
  var accentColors = "\n    ".concat(prefix).concat(id, "-bg-color-").concat(newIndex).concat(suffix, ": var(").concat(prefix).concat(id, "-color-").concat(oldColorIndex + 1, ");\n    ").concat(prefix).concat(id, "-accent-color-").concat(newIndex).concat(suffix, ": var(").concat(prefix).concat(id, "-color-").concat(accentColorIndex + 1, ");\n  ");
  var darkColors = '';

  if (oldColorIndex < lightColorsCount) {
    darkColors = "\n      ".concat(prefix).concat(id, "-fg1-color-").concat(newIndex).concat(suffix, ": var(").concat(prefix).concat(id, "-text-color-1);\n      ").concat(prefix).concat(id, "-fg2-color-").concat(newIndex).concat(suffix, ": var(").concat(prefix).concat(id, "-text-color-2);\n    ");
  } else {
    darkColors = "\n      ".concat(prefix).concat(id, "-fg1-color-").concat(newIndex).concat(suffix, ": var(").concat(prefix).concat(id, "-color-1);\n      ").concat(prefix).concat(id, "-fg2-color-").concat(newIndex).concat(suffix, ": var(").concat(prefix).concat(id, "-color-1);\n    ");
  }

  return "\n    ".concat(accentColors, "\n    ").concat(darkColors, "\n  ");
};
;// CONCATENATED MODULE: ./src/_js/customizer/svg/customize-colors-usage.svg


var customize_colors_usage_symbol = new (browser_symbol_default())({
  "id": "customize-colors-usage",
  "use": "customize-colors-usage-usage",
  "viewBox": "0 0 24 24",
  "content": "<symbol viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" id=\"customize-colors-usage\">\n<path d=\"M16.56 8.94L7.62 0L6.21 1.41L8.59 3.79L3.44 8.94C2.85 9.53 2.85 10.48 3.44 11.06L8.94 16.56C9.23 16.85 9.62 17 10 17C10.38 17 10.77 16.85 11.06 16.56L16.56 11.06C17.15 10.48 17.15 9.53 16.56 8.94ZM5.21 10L10 5.21L14.79 10H5.21ZM19 11.5C19 11.5 17 13.67 17 15C17 16.1 17.9 17 19 17C20.1 17 21 16.1 21 15C21 13.67 19 11.5 19 11.5ZM2 20H22V24H2V20Z\" fill=\"#2F384C\" />\n</symbol>"
});
var customize_colors_usage_result = browser_sprite_build_default().add(customize_colors_usage_symbol);
/* harmony default export */ var customize_colors_usage = (customize_colors_usage_symbol);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/builder/index.js
function builder_slicedToArray(arr, i) { return builder_arrayWithHoles(arr) || builder_iterableToArrayLimit(arr, i) || builder_unsupportedIterableToArray(arr, i) || builder_nonIterableRest(); }

function builder_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function builder_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return builder_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return builder_arrayLikeToArray(o, minLen); }

function builder_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function builder_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function builder_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }














var Builder = function Builder(props) {
  var sourceSettingID = props.sourceSettingID,
      outputSettingID = props.outputSettingID;
  var sourceSetting = wp.customize(sourceSettingID);

  var _useState = (0,external_React_namespaceObject.useState)(getColorsFromInputValue(sourceSetting())),
      _useState2 = builder_slicedToArray(_useState, 2),
      config = _useState2[0],
      setConfig = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)(''),
      _useState4 = builder_slicedToArray(_useState3, 2),
      CSSOutput = _useState4[0],
      setCSSOutput = _useState4[1];

  var activePresetSetting = wp.customize('sm_color_palette_in_use');
  var activePresetValue = activePresetSetting ? activePresetSetting() : null;

  var _useState5 = (0,external_React_namespaceObject.useState)(activePresetValue),
      _useState6 = builder_slicedToArray(_useState5, 2),
      activePreset = _useState6[0],
      setActivePreset = _useState6[1];

  var resetActivePreset = (0,external_React_namespaceObject.useCallback)(function () {
    setActivePreset(null);
  }, []);
  (0,external_React_namespaceObject.useEffect)(function () {
    wp.customize('sm_color_palette_in_use', function (setting) {
      setting.set(activePreset);
    });
    wp.customize('sm_is_custom_color_palette', function (setting) {
      setting.set(activePreset === null);
    });
  }, [activePreset]);

  var updateSource = function updateSource(newValue) {
    wp.customize(sourceSettingID, function (setting) {
      setting.set(getValueFromColors(newValue));
    });
  };

  var onSourceChange = function onSourceChange(newValue) {
    var newConfig = getColorsFromInputValue(newValue);
    var newPalettes = getPalettesFromColors(newConfig);
    setConfig(getColorsFromInputValue(newValue));
    wp.customize(outputSettingID, function (setting) {
      setting.set(JSON.stringify(newPalettes));
    });
  };

  var onOutputChange = function onOutputChange(value) {
    var palettes = JSON.parse(value);
    wp.customize('sm_site_color_variation', function (setting) {
      var variation = setting();
      setCSSOutput(getCSSFromPalettes(palettes, variation));
    });
  };

  var onSiteVariationChange = function onSiteVariationChange(newVariation) {
    wp.customize(outputSettingID, function (setting) {
      var output = setting();
      var palettes = JSON.parse(output);
      setCSSOutput(getCSSFromPalettes(palettes, newVariation));
    });
  };

  use_customize_setting_callback(sourceSettingID, onSourceChange);
  use_customize_setting_callback(outputSettingID, onOutputChange);
  use_customize_setting_callback('sm_site_color_variation', onSiteVariationChange);
  (0,external_React_namespaceObject.useEffect)(function () {
    var callback = function callback(isExpanded) {
      if (!isExpanded) {
        popFromBackArray();
      }
    };

    var sourceSection = wp.customize.section('sm_color_usage_section');

    if (!sourceSection) {
      return;
    }

    sourceSection.expanded.bind(callback);
    return function () {
      sourceSection.expanded.unbind(callback);
    };
  }, []);
  return /*#__PURE__*/external_React_default().createElement(context.Provider, {
    value: {
      config: config,
      setConfig: updateSource,
      resetActivePreset: resetActivePreset
    }
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-group"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-panel-toggle",
    onClick: function onClick() {
      wp.customize.section('sm_color_usage_section', function (colorUsageSection) {
        pushToBackArray(colorUsageSection, 'sm_color_palettes_section');
      });
    }
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-panel-toggle__icon",
    dangerouslySetInnerHTML: {
      __html: "\n                <svg viewBox=\"".concat(customize_colors_usage.viewBox, "\">\n                  <use xlink:href=\"#").concat(customize_colors_usage.id, "\" />\n                </svg>")
    }
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-panel-toggle__label"
  }, styleManager.l10n.colorPalettes.builderColorUsagePanelLabel))), /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-group"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-group__body"
  }, /*#__PURE__*/external_React_default().createElement(Control, {
    label: styleManager.l10n.colorPalettes.builderBrandColorsLabel
  }, /*#__PURE__*/external_React_default().createElement(SourceColors, {
    sourceSetting: sourceSetting,
    onChange: function onChange() {
      setActivePreset(null);
    }
  }), /*#__PURE__*/external_React_default().createElement("style", null, CSSOutput)))), /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-group"
  }, /*#__PURE__*/external_React_default().createElement(Accordion, null, /*#__PURE__*/external_React_default().createElement(AccordionSection, {
    title: styleManager.l10n.colorPalettes.builderColorPresetsTitle,
    open: true
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "customize-control-description"
  }, styleManager.l10n.colorPalettes.builderColorPresetsDesc), /*#__PURE__*/external_React_default().createElement(palette_list, {
    active: activePreset,
    onChange: function onChange(preset) {
      updateSource(preset.config);
      setActivePreset(preset.uid);
    }
  })), /*#__PURE__*/external_React_default().createElement(AccordionSection, {
    title: styleManager.l10n.colorPalettes.builderImageExtractTitle
  }, /*#__PURE__*/external_React_default().createElement(dropzone, null)))));
};

var Control = function Control(props) {
  var label = props.label,
      children = props.children;
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-control"
  }, label && /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-control__header"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-control__label"
  }, label)), children && /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-control__body"
  }, children));
};
;// CONCATENATED MODULE: ./src/_js/customizer/colors/color-palette-builder/index.js



var initializePaletteBuilder = function initializePaletteBuilder(sourceSettingID, outputSettingID) {
  var containerID = "customize-control-".concat(sourceSettingID, "_control");
  var container = document.getElementById(containerID);
  var target = document.createElement('DIV');

  if (typeof container === "undefined") {
    return;
  }

  container.children.forEach(function (child) {
    child.style.display = 'none';
  });
  container.insertBefore(target, container.firstChild);
  external_ReactDOM_default().render( /*#__PURE__*/external_React_default().createElement(Builder, {
    sourceSettingID: sourceSettingID,
    outputSettingID: outputSettingID
  }), target);
};
;// CONCATENATED MODULE: ./src/_js/customizer/colors/color-palettes-preview/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/overlay/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/overlay/index.js



var Overlay = function Overlay(props) {
  var show = props.show;
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-overlay sm-overlay--".concat(show ? 'visible' : 'hidden')
  }, props.children);
};

/* harmony default export */ var overlay = (Overlay);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/preview/style.scss
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/_js/customizer/colors/components/preview/index.js
function preview_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function preview_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { preview_ownKeys(Object(source), true).forEach(function (key) { preview_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { preview_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function preview_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function preview_slicedToArray(arr, i) { return preview_arrayWithHoles(arr) || preview_iterableToArrayLimit(arr, i) || preview_unsupportedIterableToArray(arr, i) || preview_nonIterableRest(); }

function preview_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function preview_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return preview_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return preview_arrayLikeToArray(o, minLen); }

function preview_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function preview_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function preview_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





var Preview = function Preview(props) {
  return /*#__PURE__*/external_React_default().createElement(external_React_namespaceObject.Fragment, null, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-header sm-palette-1 sm-palette--shifted sm-variation-1"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-overlay__wrap"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-overlay__container"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-header-wrap"
  }, /*#__PURE__*/external_React_default().createElement("h1", {
    className: "palette-preview-title"
  }, styleManager.l10n.colorPalettes.palettePreviewTitle), /*#__PURE__*/external_React_default().createElement("p", {
    className: "palette-preview-description"
  }, styleManager.l10n.colorPalettes.palettePreviewDesc))))), /*#__PURE__*/external_React_default().createElement(PalettePreviewList, props));
};

var PalettePreviewList = function PalettePreviewList(props) {
  var palettes = props.palettes;
  var userPalettes = palettes.filter(function (palette) {
    var id = palette.id;
    return !(typeof id === 'string' && id.charAt(0) === '_');
  });

  if (!userPalettes.length) {
    return null;
  }

  var _useState = (0,external_React_namespaceObject.useState)(userPalettes[0].id),
      _useState2 = preview_slicedToArray(_useState, 2),
      active = _useState2[0],
      setActive = _useState2[1];

  return userPalettes.map(function (palette, index) {
    var description = index === 0 ? styleManager.l10n.colorPalettes.palettePreviewListDesc : '';
    return /*#__PURE__*/external_React_default().createElement(PalettePreview, {
      key: palette.id,
      isActive: active === palette.id,
      setActivePalette: setActive,
      palette: preview_objectSpread({
        description: description
      }, palette)
    });
  });
};

var PalettePreview = function PalettePreview(props) {
  var palette = props.palette,
      isActive = props.isActive,
      setActivePalette = props.setActivePalette;
  var id = palette.id,
      colors = palette.colors,
      textColors = palette.textColors,
      lightColorsCount = palette.lightColorsCount,
      sourceIndex = palette.sourceIndex;

  var _useState3 = (0,external_React_namespaceObject.useState)(sourceIndex),
      _useState4 = preview_slicedToArray(_useState3, 2),
      lastHover = _useState4[0],
      setLastHover = _useState4[1];

  var siteVariationSetting = wp.customize('sm_site_color_variation');

  var _useState5 = (0,external_React_namespaceObject.useState)(parseInt(siteVariationSetting(), 10)),
      _useState6 = preview_slicedToArray(_useState5, 2),
      siteVariation = _useState6[0],
      setSiteVariation = _useState6[1];

  var onSiteVariationChange = function onSiteVariationChange(newValue) {
    setSiteVariation(parseInt(newValue, 10));
  };

  (0,external_React_namespaceObject.useEffect)(function () {
    setLastHover(sourceIndex);
  }, [colors]);
  (0,external_React_namespaceObject.useEffect)(function () {
    // Attach the listeners on component mount.
    siteVariationSetting.bind(onSiteVariationChange); // Detach the listeners on component unmount.

    return function () {
      siteVariationSetting.unbind(onSiteVariationChange);
    };
  }, []);

  var normalize = function normalize(index) {
    return (index + siteVariation - 1 + 12) % 12;
  };

  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview sm-palette-".concat(id, " ").concat(lastHover !== false ? "sm-variation-".concat(lastHover + 1) : '')
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-overlay__wrap"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-overlay__container"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-set"
  }, colors.map(function (color, index) {
    var variation = index + 1;
    var showLightForeground = normalize(index) === 0;
    var showDarkForeground = normalize(index) === 9;
    var foregroundToShow = normalize(lastHover) >= lightColorsCount ? showLightForeground : showDarkForeground;
    var passedProps = {
      isSource: normalize(index) === sourceIndex,
      showCard: isActive && index === lastHover,
      showAccent: isActive && lastHover !== false && index === (lastHover + 6) % 12,
      showForeground: isActive && lastHover !== false && foregroundToShow,
      textColor: normalize(index) >= lightColorsCount ? textColors[0].value : '#FFFFFF',
      variation: variation
    };
    return /*#__PURE__*/external_React_default().createElement("div", {
      key: index,
      className: "palette-preview-swatches sm-variation-".concat(variation),
      onMouseEnter: function onMouseEnter() {
        setActivePalette(id);
        setLastHover(index);
      }
    }, /*#__PURE__*/external_React_default().createElement(PalettePreviewGrade, passedProps));
  })))));
};

var getStarVariation = function getStarVariation(variation) {
  return variation > 10 ? variation - 2 : variation + 2;
};

var PalettePreviewGrade = function PalettePreviewGrade(props) {
  var isSource = props.isSource,
      showCard = props.showCard,
      showAccent = props.showAccent,
      showForeground = props.showForeground,
      textColor = props.textColor,
      variation = props.variation;
  var className = classnames_default()('palette-preview-swatches__wrap', {
    'is-source': isSource,
    'show-card': showCard,
    'show-accent': showAccent,
    'show-fg': showForeground
  });
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: className
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__wrap-surface"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__text"
  }, styleManager.l10n.colorPalettes.palettePreviewSwatchSurfaceText), /*#__PURE__*/external_React_default().createElement(PalettePreviewGradeCard, {
    variation: variation
  })), /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__wrap-background",
    style: {
      color: 'var(--sm-current-bg-color)'
    }
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__wrap-accent",
    style: {
      color: 'var(--sm-current-bg-color)'
    }
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__source-badge sm-variation-".concat(getStarVariation(variation))
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__text"
  }, styleManager.l10n.colorPalettes.palettePreviewSwatchSurfaceText)), /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__wrap-foreground",
    style: {
      color: textColor
    }
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__text"
  }, styleManager.l10n.colorPalettes.palettePreviewSwatchSurfaceText)));
};

var PalettePreviewGradeCard = function PalettePreviewGradeCard(props) {
  var variation = props.variation;
  var buttonVariation = (variation - 1 + 6) % 12 + 1;
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__card"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__card-content"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__source-badge sm-variation-".concat(getStarVariation(variation))
  }), /*#__PURE__*/external_React_default().createElement("h2", {
    className: "palette-preview-swatches__title"
  }, "Text"), /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__body"
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__row"
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__row"
  })), /*#__PURE__*/external_React_default().createElement("div", {
    className: "palette-preview-swatches__button sm-variation-".concat(buttonVariation)
  }, "\u2192")));
};

/* harmony default export */ var preview = (Preview);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/color-palettes-preview/index.js
function color_palettes_preview_slicedToArray(arr, i) { return color_palettes_preview_arrayWithHoles(arr) || color_palettes_preview_iterableToArrayLimit(arr, i) || color_palettes_preview_unsupportedIterableToArray(arr, i) || color_palettes_preview_nonIterableRest(); }

function color_palettes_preview_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function color_palettes_preview_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return color_palettes_preview_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return color_palettes_preview_arrayLikeToArray(o, minLen); }

function color_palettes_preview_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function color_palettes_preview_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function color_palettes_preview_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







var PreviewTabs = function PreviewTabs(props) {
  var _useState = (0,external_React_namespaceObject.useState)('site'),
      _useState2 = color_palettes_preview_slicedToArray(_useState, 2),
      active = _useState2[0],
      setActive = _useState2[1];

  var previewedDevice = wp.customize.previewedDevice.get();

  var _useState3 = (0,external_React_namespaceObject.useState)(previewedDevice === 'desktop'),
      _useState4 = color_palettes_preview_slicedToArray(_useState3, 2),
      visible = _useState4[0],
      setVisible = _useState4[1];

  var previewRef = (0,external_React_namespaceObject.useRef)();
  var previewHeaderRef = (0,external_React_namespaceObject.useRef)();
  var setting = wp.customize('sm_advanced_palette_output');
  var tabs = [{
    id: 'site',
    label: styleManager.l10n.colorPalettes.previewTabLiveSiteLabel
  }, {
    id: 'colors',
    label: styleManager.l10n.colorPalettes.previewTabColorSystemLabel,
    callback: function callback() {
      wp.customize.section('sm_color_palettes_section', function (section) {
        section.focus();
      });
    }
  }];
  wp.customize.section('sm_color_palettes_section', function (section) {
    (0,external_React_namespaceObject.useEffect)(function () {
      var callback = function callback(expanded) {
        if (expanded) {
          setActive('colors');
        }
      };

      section.expanded.bind(callback);
      return function () {
        section.expanded.unbind(callback);
      };
    });
  });
  (0,external_React_namespaceObject.useEffect)(function () {
    var _window, _window$sm, _window$sm$customizer;

    var previewResizer = (_window = window) === null || _window === void 0 ? void 0 : (_window$sm = _window.sm) === null || _window$sm === void 0 ? void 0 : (_window$sm$customizer = _window$sm.customizer) === null || _window$sm$customizer === void 0 ? void 0 : _window$sm$customizer.resizer;

    if (!previewResizer) {
      return;
    }

    var top = previewHeaderRef.current.offsetHeight;
    var style = getComputedStyle(previewRef.current, null);
    var left = parseFloat(style.left.replace("px", ""));
    var right = parseFloat(style.right.replace("px", ""));
    previewResizer.setOffset({
      top: top,
      right: right,
      bottom: 0,
      left: left
    });
    previewResizer.resize();
  }, []);
  (0,external_React_namespaceObject.useEffect)(function () {
    var callback = function callback(previewdDevice) {
      setVisible(previewdDevice === 'desktop');
    };

    wp.customize.previewedDevice.bind(callback);
    return function () {
      wp.customize.previewedDevice.unbind(callback);
    };
  }, []);
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-preview ".concat(visible ? 'sm-preview--visible' : ''),
    ref: previewRef
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-preview__header",
    ref: previewHeaderRef
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-preview__tabs"
  }, tabs.map(function (tab) {
    var isActive = active === tab.id;

    var noop = function noop() {};

    var callback = typeof tab.callback === 'function' ? tab.callback : noop;
    return /*#__PURE__*/external_React_default().createElement("div", {
      key: tab.id,
      className: "sm-preview__tab ".concat(isActive ? 'sm-preview__tab--active' : ''),
      onClick: function onClick() {
        setActive(tab.id);
        callback();
      }
    }, tab.label);
  }))), /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-preview__content"
  }, /*#__PURE__*/external_React_default().createElement(ColorsOverlay, {
    show: active === 'colors',
    setting: setting
  })));
};

var initializePreview = function initializePreview() {
  wp.customize.bind('ready', function () {
    wp.customize.panel('style_manager_panel', function (smPanel) {
      wp.customize.section('sm_color_palettes_section', function (smColorsSection) {
        wp.customize.previewer.bind('ready', function () {
          var iframe = document.querySelector('#customize-preview iframe');

          if (!iframe) {
            return;
          }

          var smPreviewTabs = document.createElement('div');
          iframe.insertAdjacentElement('beforebegin', smPreviewTabs);
          external_ReactDOM_default().render( /*#__PURE__*/external_React_default().createElement(PreviewTabs, {
            smPanel: smPanel
          }), smPreviewTabs);
        });
      });
    });
  });
};

var ColorsOverlay = function ColorsOverlay(props) {
  var setting = props.setting,
      show = props.show;

  var _useState5 = (0,external_React_namespaceObject.useState)(JSON.parse(setting())),
      _useState6 = color_palettes_preview_slicedToArray(_useState5, 2),
      palettes = _useState6[0],
      setPalettes = _useState6[1];

  var changeListener = function changeListener(newValue) {
    setPalettes(JSON.parse(newValue));
  };

  (0,external_React_namespaceObject.useEffect)(function () {
    // Attach the listeners on component mount.
    setting.bind(changeListener); // Detach the listeners on component unmount.

    return function () {
      setting.unbind(changeListener);
    };
  }, []);
  return /*#__PURE__*/external_React_default().createElement(overlay, {
    show: show
  }, /*#__PURE__*/external_React_default().createElement(preview, {
    palettes: palettes
  }));
};

/* harmony default export */ var color_palettes_preview = (initializePreview);
;// CONCATENATED MODULE: ./src/_js/customizer/colors/index.js







var initializeColors = function initializeColors() {
  initializePaletteBuilder('sm_advanced_palette_source', 'sm_advanced_palette_output');
  wp.customize('sm_coloration_level', function (setting) {
    setting.bind(applyColorationValueToFields);
  });
  initializeColorizeElementsButton();
  color_palettes_preview();
};

var ColorizeElementsButton = function ColorizeElementsButton(props) {
  var targetSectionID = "".concat(styleManager.config.options_name, "[colors_section]");
  (0,external_React_namespaceObject.useEffect)(function () {
    var callback = function callback(isExpanded) {
      if (!isExpanded) {
        var backArray = getBackArray();

        var _targetSectionID = backArray.pop();

        if (_targetSectionID) {
          wp.customize.section(_targetSectionID, function (targetSection) {
            targetSection.focus();
          });
        }
      }
    };

    var targetSection = wp.customize.section(targetSectionID);

    if (!targetSection) {
      return;
    }

    targetSection.expanded.bind(callback);
    return function () {
      targetSection.expanded.unbind(callback);
    };
  }, []);
  return /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-group",
    style: {
      marginTop: 0
    }
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-panel-toggle",
    id: "sm-colorize-elements-button",
    style: {
      borderTopWidth: 0
    },
    onClick: function onClick() {
      wp.customize.section(targetSectionID, function (targetSection) {
        pushToBackArray(targetSection, 'sm_color_usage_section');
      });
    }
  }, /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-panel-toggle__icon",
    dangerouslySetInnerHTML: {
      __html: "\n                <svg viewBox=\"".concat(colorize_elements.viewBox, "\">\n                  <use xlink:href=\"#").concat(colorize_elements.id, "\" />\n                </svg>")
    }
  }), /*#__PURE__*/external_React_default().createElement("div", {
    className: "sm-panel-toggle__label"
  }, styleManager.l10n.colorPalettes.colorizeElementsPanelLabel)));
};

var initializeColorizeElementsButton = function initializeColorizeElementsButton() {
  var target = document.getElementById('customize-control-sm_coloration_level_control');
  var button = document.createElement('li');
  button.setAttribute('class', 'customize-control');
  button.setAttribute('style', 'padding: 0');
  target.insertAdjacentElement('afterend', button);
  external_ReactDOM_default().render( /*#__PURE__*/external_React_default().createElement(ColorizeElementsButton, null), button);
};

var applyColorationValueToFields = function applyColorationValueToFields(colorationLevel) {
  var defaultColorationLevel = getSettingConfig('sm_coloration_level').default;
  var isDefaultColoration = colorationLevel === defaultColorationLevel;
  var settings = getSettings();
  var value = parseInt(colorationLevel, 10);
  var threshold = value < 50 ? 4 : value < 75 ? 3 : value < 100 ? 2 : 1;
  Object.keys(settings).forEach(function (settingID) {
    var config = getSettingConfig(settingID);

    if ((config === null || config === void 0 ? void 0 : config.type) === 'sm_toggle') {
      var coloration = config.coloration;
      wp.customize(settingID, function (setting) {
        setting.set(isDefaultColoration ? config.default : coloration >= threshold);
      });
    }
  });
};
;// CONCATENATED MODULE: ./src/_js/utils.js
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
var debounce = function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/index.js













var wrapperSelector = '.font-options__wrapper';
var valueHolderSelector = '.style-manager_font_values';
var getSettingID = function getSettingID($element) {
  return getWrapper($element).find(valueHolderSelector).data('customize-setting-link');
};
var getWrapper = function getWrapper($element) {
  return $element.closest(wrapperSelector);
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/handle-font-popup-toggle.js

var handleFontPopupToggle = function handleFontPopupToggle() {
  var $allFontCheckboxes = external_jQuery_default()('.js-font-option-toggle'); // Close all other font fields popups when opening a font field popup.

  $allFontCheckboxes.on('click', function (event) {
    $allFontCheckboxes.not(event.target).prop('checked', false);
  }); // Make sure that all fonts popups are closed when backing away from a panel or section.
  // @todo This doesn't catch backing with ESC key. For that we should hook on Customizer section and panel events ('collapsed').

  external_jQuery_default()('#customize-controls .customize-panel-back, #customize-controls .customize-section-back').on('click', function () {
    $allFontCheckboxes.prop('checked', false);
  });
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/fonts-service.js
var updating = {};
var loading = {};
var isLoading = function isLoading(settingID) {
  return !!updating[settingID];
};
var isUpdating = function isUpdating(settingID) {
  return !!loading[settingID];
};
var setLoading = function setLoading(settingID, value) {
  loading[settingID] = value;
};
var setUpdating = function setUpdating(settingID, value) {
  updating[settingID] = value;
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/standardize-numerical-value.js

/**
 * Given a value we will standardize it to an array with 'value' and 'unit'.
 *
 * This is a mirror logic of the server-side one from Utils\Fonts::standardizeNumericalValue()
 *
 * @param value
 * @param input Optional. The input this value was extracted from
 * @param valueFirst Optional. Whether to give higher priority to value related data, or to input related one.
 */

var standardizeNumericalValue = function standardizeNumericalValue(value) {
  var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var valueFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var standardValue = {
    value: false,
    unit: false
  };

  if (_.includes(['', 'false', false], value)) {
    return standardValue;
  }

  if (!isNaN(value)) {
    standardValue.value = value;
  } else if (typeof value.value !== 'undefined') {
    standardValue.value = value.value;

    if (typeof value.unit !== 'undefined') {
      standardValue.unit = value.unit;
    }
  } else if (typeof value[0] !== 'undefined') {
    standardValue.value = value[0];

    if (typeof value[1] !== 'undefined') {
      standardValue.unit = value[1];
    }
  } else if (typeof value === 'string') {
    // We will get everything in front that is a valid part of a number (float including).
    var matches = value.match(/^([\d.\-+]+)(.+)/i);

    if (matches !== null && typeof matches[1] !== 'undefined') {
      standardValue.value = matches[1];

      if (!_.isEmpty(matches[2])) {
        standardValue.unit = matches[2];
      }
    } else {
      // If we could not extract anything useful we will trust the developer and leave it like that.
      standardValue.value = value;
    }
  }

  if (false !== input && (false === standardValue.unit || _.isEmpty(standardValue.unit))) {
    // If we are given an input, we will attempt to extract the unit from its attributes.
    var fallbackInputUnit = '';
    var $input = external_jQuery_default()(input);

    if (valueFirst) {
      if (!_.isEmpty($input.data('value_unit'))) {
        fallbackInputUnit = $input.data('value_unit');
      } else if (!_.isEmpty($input.attr('unit'))) {
        fallbackInputUnit = $input.attr('unit');
      }
    } else {
      if (!_.isEmpty($input.attr('unit'))) {
        fallbackInputUnit = $input.attr('unit');
      } else if (!_.isEmpty($input.data('value_unit'))) {
        fallbackInputUnit = $input.data('value_unit');
      }
    }

    standardValue.unit = fallbackInputUnit;
  } // Make sure that if we have a numerical value, it is a float.


  if (!isNaN(standardValue.value)) {
    standardValue.value = parseFloat(standardValue.value);
  }

  return standardValue;
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/determine-font-type.js
var determineFontType = function determineFontType(fontFamily) {
  // The default is a standard font (aka no special loading or processing).
  var fontType = 'system_font'; // We will follow a stack in the following order: third-party fonts, cloud fonts, theme fonts, Google fonts, standard fonts.

  if (typeof styleManager.fonts.third_party_fonts[fontFamily] !== 'undefined') {
    fontType = 'third_party_font';
  } else if (typeof styleManager.fonts.cloud_fonts[fontFamily] !== 'undefined') {
    fontType = 'cloud_font';
  } else if (typeof styleManager.fonts.theme_fonts[fontFamily] !== 'undefined') {
    fontType = 'theme_font';
  } else if (typeof styleManager.fonts.google_fonts[fontFamily] !== 'undefined') {
    fontType = 'google_font';
  }

  return fontType;
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/get-font-details.js

var getFontDetails = function getFontDetails(fontFamily) {
  var fontType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (false === fontType) {
    // We will determine the font type based on font family.
    fontType = determineFontType(fontFamily);
  }

  switch (fontType) {
    case 'theme_font':
      return styleManager.fonts.theme_fonts[fontFamily];
      break;

    case 'cloud_font':
      return styleManager.fonts.cloud_fonts[fontFamily];
      break;

    case 'google_font':
      return styleManager.fonts.google_fonts[fontFamily];
      break;

    case 'system_font':
      if (typeof styleManager.fonts.system_fonts[fontFamily] !== 'undefined') {
        return styleManager.fonts.system_fonts[fontFamily];
      }

      break;

    case 'third_party_font':
      if (typeof styleManager.fonts.third_party_fonts[fontFamily] !== 'undefined') {
        return styleManager.fonts.third_party_fonts[fontFamily];
      }

      break;

    default:
  }

  return false;
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/self-update-value.js


/**
 * Gather the value for our entire font field and save it in the setting.
 */

var selfUpdateValue = function selfUpdateValue(wrapper, settingID) {
  // If we are already self-updating this and we haven't finished, we need to stop here to prevent infinite loops
  // This call might have come from a subfield detecting the change thus triggering a further selfUpdateValue()
  // If we are loading this setting value and haven't finished,
  // there is no point in updating it as this would cause infinite loops.
  if (isUpdating(settingID) || isLoading(settingID)) {
    return;
  } // Mark the fact that we are self-updating the field value


  setUpdating(settingID, true);
  var optionsList = wrapper.find('.font-options__options-list');
  var inputs = optionsList.find('[data-value_entry]');
  var newFontData = {};
  wp.customize(settingID, function (setting) {
    newFontData = external_jQuery_default().extend(true, {}, setting());
    inputs.each(function (key, input) {
      var $input = external_jQuery_default()(input);
      var valueEntry = $input.data('value_entry');
      var value = $input.val(); // We only pick up subfields values that have been touched by the user, that are enabled (visible) or values that are missing in the oldValue.

      if (_.isUndefined(valueEntry) || $input.data('disabled') || !$input.data('touched') && !_.isUndefined(newFontData[valueEntry])) {
        return;
      }

      if ('font_family' === valueEntry) {
        // Get the src of the selected option.
        var src = external_jQuery_default()(input.options[input.selectedIndex]).data('src');

        if (src) {
          newFontData['src'] = src;
        } else {
          delete newFontData['src'];
        }
      }

      if (!_.isUndefined(value) && !_.isNull(value) && value !== '') {
        if (_.includes(['letter_spacing', 'line_height', 'font_size'], valueEntry)) {
          // Standardize the value.
          value = standardizeNumericalValue(value, input, false);
        }

        newFontData[valueEntry] = value;
      } else {
        delete newFontData[valueEntry];
      }
    }); // We don't need to store font variants or subsets list in the value
    // since we will get those from the global font details.

    delete newFontData['variants'];
    delete newFontData['subsets']; // We need to make sure that we don't "use" any variants not supported by the new font (values passed over from the old value).
    // Get the new font details

    var newFontDetails = getFontDetails(newFontData['font_family']); // Check the font variant

    if (typeof newFontData['font_variant'] !== 'undefined' && typeof newFontDetails.variants !== 'undefined' && Object.keys(newFontDetails.variants).length > 0) {
      // Make sure that the font_variant is a string, not a number.
      newFontData['font_variant'] = String(newFontData['font_variant']);

      if (!_.includes(newFontDetails.variants, newFontData['font_variant'])) {
        // The new font doesn't have this variant. Nor should the value.
        delete newFontData['font_variant'];
      }
    } else {
      // The new font has no variants. Nor should the value.
      delete newFontData['font_variant'];
    } // Update the Customizer setting value.


    setting.set(newFontData);
  }); // Finished with the field value self-updating.

  setUpdating(settingID, false);
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/init-subfield.js


var initSubfield = function initSubfield($subField) {
  var select2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  // Mark these as not touched by the user.
  $subField.data('touched', false);
  $subField.on('input change', onSubfieldChange); // If we've been instructed, initialize a select2.

  if (true === select2) {
    $subField.select2();
  }
};

var onSubfieldChange = function onSubfieldChange(event, who) {
  var $subField = external_jQuery_default()(event.target); // The change was triggered programmatically by Style Manager.
  // No need to self-update the value.

  if ('style-manager' === who) {
    return;
  }

  var wrapper = getWrapper($subField);
  var settingID = getSettingID($subField); // Mark this input as touched by the user.

  $subField.data('touched', true); // Gather subfield values and trigger refresh of the fonts in the preview window.

  selfUpdateValue(wrapper, settingID);
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/update-font-head-title.js

/**
 * Update the title of the font field (the field head) with the new font family name.
 *
 * @param newFontDetails
 * @param wrapper
 */

var updateFontHeadTitle = function updateFontHeadTitle(newFontDetails, wrapper) {
  var fontTitleElement = wrapper.find('.font-options__head .font-options__font-title');
  var fontFamilyDisplay = newFontDetails.family;

  if (typeof newFontDetails.family_display === 'string' && newFontDetails.family_display.length) {
    fontFamilyDisplay = newFontDetails.family_display;
  }

  external_jQuery_default()(fontTitleElement).html(fontFamilyDisplay);
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/update-variant-field.js

var fontVariantSelector = '.style-manager_font_weight';
/**
 * This function updates the data in font weight selector from the given <option> element
 *
 * @param newFontDetails
 * @param wrapper
 */

var updateVariantField = function updateVariantField(newFontDetails, wrapper) {
  var variants = typeof newFontDetails.variants !== 'undefined' ? newFontDetails.variants : [],
      fontVariantInput = wrapper.find(fontVariantSelector),
      selectedVariant = fontVariantInput.val() ? fontVariantInput.val() : '',
      newVariants = []; // We clear everything about this subfield.

  fontVariantInput.val(null).empty();

  if (fontVariantInput.hasClass("select2-hidden-accessible")) {
    fontVariantInput.select2('destroy');
  } // Mark this input as not touched by the user.


  fontVariantInput.data('touched', false);

  if (typeof variants === 'undefined' || Object.keys(variants).length < 2) {
    fontVariantInput.parent().hide();
    fontVariantInput.parent().prev('label').hide(); // Mark this input as disabled.

    fontVariantInput.data('disabled', true);
    return;
  }

  var variantAutoText = styleManager.l10n.fonts.variantAutoText; // Initialize the options with an empty one.

  newVariants.push({
    'id': '',
    'text': variantAutoText
  }); // we need to turn the data array into a specific form like [{id:"id", text:"Text"}]

  external_jQuery_default().each(variants, function (index, variant) {
    var newVariant = {
      'id': variant,
      // This is the option value.
      'text': variant
    }; // Leave the comparison loose.

    if (selectedVariant == variant) {
      newVariant.selected = true;
    }

    newVariants.push(newVariant);
  }); // This is a costly operation especially when font palettes are changed and multiple font fields are updated

  requestIdleCallback(function () {
    // Only reinitialize the select2.
    // No need to rebind on change or on input since those are still bound to the original HTML element.
    fontVariantInput.select2({
      data: newVariants
    });
    fontVariantInput.parent().show();
    fontVariantInput.parent().prev('label').show(); // Mark this input as enabled.

    fontVariantInput.data('disabled', false);
  });
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/round.js
var round = function round(number, precision) {
  var factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/load-font-value.js




/**
 * This function is a reverse of selfUpdateValue(), initializing the entire font field controls
 * based on the setting value.
 */

var loadFontValue = function loadFontValue(wrapper, value, settingID) {
  // If we are already loading this setting value and haven't finished, there is no point in starting again.
  if (isLoading(settingID)) {
    return;
  } // Mark the fact that we are loading the field value


  setLoading(settingID, true);
  var optionsList = external_jQuery_default()(wrapper).find('.font-options__options-list'),
      inputs = optionsList.find('[data-value_entry]');
  inputs.each(function (key, input) {
    var $input = external_jQuery_default()(input);
    var valueEntry = $input.data('value_entry'); // In the case of select2, only the original selects have the data field, thus excluding select2 created select DOM elements

    if (typeof valueEntry === 'undefined' || valueEntry === '' || typeof value[valueEntry] === 'undefined') {
      return;
    } // We will do this only for numerical sub-fields.


    if (_.includes(['letter_spacing', 'line_height', 'font_size'], valueEntry)) {
      var subfieldValue = standardizeNumericalValue(value[valueEntry], input); // Make sure that the unit and value_unit attributes are in place.

      if (subfieldValue.unit !== '') {
        $input.data('value_unit', subfieldValue.unit);

        if (_.isEmpty($input.attr('unit'))) {
          $input.attr('unit', subfieldValue.unit);
        }
      } // If the field unit and value unit differ, we have some conversion to do.
      // We will convert the received value to the appropriate unit declared by the input.
      // We will use a guessed base size of 16px. Not an exact conversion, but it will have to do.


      var baseSize = 16;
      var subfieldUnit = $input.attr('unit').trim().toLowerCase();
      var subfieldValueUnit = $input.data('value_unit').trim().toLowerCase(); // The comparison is intentionally loose.

      if (subfieldUnit != subfieldValueUnit) {
        if (_.includes(['em', 'rem'], subfieldValueUnit) && 'px' === subfieldUnit) {
          // We will have to multiply the value.
          subfieldValue.value = round(subfieldValue.value * baseSize, styleManager.fonts.floatPrecision);
        } else if (_.includes(['em', 'rem'], subfieldUnit) && 'px' === subfieldValueUnit) {
          // We will have to divide the value.
          subfieldValue.value = round(subfieldValue.value / baseSize, styleManager.fonts.floatPrecision);
        }
      } // If this field has a min/max attribute we need to make sure that those attributes allow for the value we are trying to impose.


      if ($input.attr('min') && $input.attr('min') > subfieldValue.value) {
        $input.attr('min', subfieldValue.value);
      }

      if ($input.attr('max') && $input.attr('max') < subfieldValue.value) {
        $input.attr('max', subfieldValue.value);
      }

      $input.val(subfieldValue.value);
    } else {
      $input.val(value[valueEntry]);
    } // Mark this input as not touched by the user.


    $input.data('touched', false);
    $input.trigger('change', ['style-manager']);
  }); // Finished with the field value loading.

  setLoading(settingID, false);
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/callback-filter.js


var getCallbackFilter = function getCallbackFilter(connectedFieldData) {
  return function (newValue, oldValue) {
    /* ======================
     * Process the font logic to get the value that should be applied to the connected (font) fields.
     *
     * The font logic is already in the new value - @see setFieldFontsLogicConfig()
     */
    var newFontData = {};
    var fontsLogic = newValue;

    if (typeof fontsLogic.reset !== 'undefined') {
      var settingID = connectedFieldData.setting_id;
      var defaultValue = styleManager.config.settings[settingID].default;

      if (!_.isUndefined(setting) && !_.isEmpty(defaultValue)) {
        newFontData['font_family'] = defaultValue['font_family'];
        newFontData['font_size'] = defaultValue['font_size'];
        newFontData['line_height'] = defaultValue['line_height'];
        newFontData['letter_spacing'] = defaultValue['letter_spacing'];
        newFontData['text_transform'] = defaultValue['text_transform'];
        newFontData['font_variant'] = defaultValue['font_variant'];
      }
    }
    /* ===========
     * We need to determine the 6 subfields values to be able to determine the value of the font field.
     */
    // The font family is straight forward as it comes directly from the parent field font logic configuration.


    if (typeof fontsLogic.font_family !== 'undefined') {
      newFontData['font_family'] = fontsLogic.font_family;
    }

    if (_.isEmpty(newFontData['font_family'])) {
      // If we don't have a font family, we really can't do much.
      return;
    }

    if (typeof connectedFieldData.font_size !== 'undefined' && false !== connectedFieldData.font_size) {
      newFontData['font_size'] = standardizeNumericalValue(connectedFieldData.font_size); // Next, we what to apply the overall font size multiplier.

      if (!isNaN(newFontData['font_size'].value)) {
        // By default we use 1.
        var overallFontSizeMultiplier = 1.0;

        if (typeof fontsLogic.font_size_multiplier !== 'undefined') {
          // Make sure it is a positive float.
          overallFontSizeMultiplier = parseFloat(fontsLogic.font_size_multiplier); // We reject negative or 0 values.

          if (overallFontSizeMultiplier <= 0) {
            overallFontSizeMultiplier = 1.0;
          }
        }

        newFontData['font_size'].value = round(parseFloat(newFontData['font_size'].value) * overallFontSizeMultiplier, styleManager.fonts.floatPrecision);
      } // The font variant, letter spacing and text transform all come together from the font styles (intervals).
      // We just need to find the one that best matches the connected field given font size (if given).
      // Please bear in mind that we expect the font logic styles to be preprocessed, without any overlapping and using numerical keys.


      if (typeof fontsLogic.font_styles_intervals !== 'undefined' && _.isArray(fontsLogic.font_styles_intervals) && fontsLogic.font_styles_intervals.length > 0) {
        var idx = 0;

        while (idx < fontsLogic.font_styles_intervals.length - 1 && typeof fontsLogic.font_styles_intervals[idx].end !== 'undefined' && fontsLogic.font_styles_intervals[idx].end <= connectedFieldData.font_size.value) {
          idx++;
        } // We will apply what we've got.


        if (!_.isEmpty(fontsLogic.font_styles_intervals[idx].font_variant)) {
          newFontData['font_variant'] = fontsLogic.font_styles_intervals[idx].font_variant;
        }

        if (!_.isEmpty(fontsLogic.font_styles_intervals[idx].letter_spacing)) {
          newFontData['letter_spacing'] = standardizeNumericalValue(fontsLogic.font_styles_intervals[idx].letter_spacing);
        }

        if (!_.isEmpty(fontsLogic.font_styles_intervals[idx].text_transform)) {
          newFontData['text_transform'] = fontsLogic.font_styles_intervals[idx].text_transform;
        } // Next, we what to apply the interval font size multiplier.


        if (!isNaN(newFontData['font_size'].value)) {
          // By default we use 1.
          var fontSizeMultiplier = 1.0;

          if (typeof fontsLogic.font_styles_intervals[idx].font_size_multiplier !== 'undefined') {
            // Make sure it is a positive float.
            fontSizeMultiplier = parseFloat(fontsLogic.font_styles_intervals[idx].font_size_multiplier); // We reject negative or 0 values.

            if (fontSizeMultiplier <= 0) {
              fontSizeMultiplier = 1.0;
            }
          }

          newFontData['font_size'].value = round(parseFloat(newFontData['font_size'].value) * fontSizeMultiplier, styleManager.fonts.floatPrecision);
        }
      } // The line height is determined by getting the value of the polynomial function determined by points.


      if (typeof fontsLogic.font_size_to_line_height_points !== 'undefined' && _.isArray(fontsLogic.font_size_to_line_height_points)) {
        var result = regression.logarithmic(fontsLogic.font_size_to_line_height_points, {
          precision: styleManager.fonts.floatPrecision
        });
        var lineHeight = result.predict(newFontData['font_size'].value)[1];
        newFontData['line_height'] = standardizeNumericalValue(lineHeight);
      }
    }

    return newFontData;
  };
};
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/index.js





var fonts_wrapperSelector = '.font-options__wrapper';
var fonts_fontVariantSelector = '.style-manager_font_weight';
var initializeFonts = function initializeFonts() {
  var $fontFields = external_jQuery_default()(fonts_wrapperSelector);
  $fontFields.each(function (i, obj) {
    var $fontField = external_jQuery_default()(obj);
    initializeFontFamilyField($fontField);
    initializeSubfields($fontField);
  });
  handleFontPopupToggle();
  reloadConnectedFields();
};

var initializeFontFamilyField = function initializeFontFamilyField($fontField) {
  var $fontFamilyField = $fontField.find('.style-manager_font_family');
  var familyPlaceholderText = styleManager.l10n.fonts.familyPlaceholderText; // Add the Google Fonts opts to each control

  addGoogleFontsToFontFamilyField($fontFamilyField); // Initialize the select2 field for the font family

  $fontFamilyField.select2({
    placeholder: familyPlaceholderText
  });
  $fontFamilyField.on('change', onFontFamilyChange);
  bindFontFamilySettingChange($fontFamilyField);
};

var initializeSubfields = function initializeSubfields($fontField) {
  var $variant = $fontField.find(fonts_fontVariantSelector);
  var $select = $fontField.find('select').not('select[class*=\' select2\'],select[class^=\'select2\']');
  var $range = $fontField.find('input[type="range"]'); // Initialize the select2 field for the font variant

  initSubfield($variant, true); // Initialize all the regular selects in the font subfields

  initSubfield($select, false); // Initialize the all the range fields in the font subfields

  initSubfield($range, false);
};

var addGoogleFontsToFontFamilyField = function addGoogleFontsToFontFamilyField($fontFamilyField) {
  var googleFontsOptions = wp.customize.settings['google_fonts_opts'];
  var $googleOptionsPlaceholder = $fontFamilyField.find('.google-fonts-opts-placeholder').first();

  if (typeof googleFontsOptions !== 'undefined' && $googleOptionsPlaceholder.length) {
    // Replace the placeholder with the HTML for the Google fonts select options.
    $googleOptionsPlaceholder.replaceWith(googleFontsOptions); // The active font family might be a Google font so we need to set the current value after we've added the options.

    var activeFontFamily = $fontFamilyField.data('active_font_family');

    if (typeof activeFontFamily !== 'undefined') {
      $fontFamilyField.val(activeFontFamily);
    }
  }
};

var onFontFamilyChange = function onFontFamilyChange(event) {
  var newFontFamily = event.target.value;
  var $target = external_jQuery_default()(event.target);
  var $wrapper = $target.closest(fonts_wrapperSelector); // Get the new font details

  var newFontDetails = getFontDetails(newFontFamily); // Update the font field head title (with the new font family name).

  updateFontHeadTitle(newFontDetails, $wrapper); // Update the variant subfield with the new options given by the selected font family.

  updateVariantField(newFontDetails, $wrapper);

  if (typeof who !== 'undefined' && who === 'style-manager') {// The change was triggered programmatically by Style Manager.
    // No need to self-update the value.
  } else {
    // Mark this input as touched by the user.
    external_jQuery_default()(event.target).data('touched', true); // Serialize subfield values and refresh the fonts in the preview window.

    selfUpdateValue($wrapper, getSettingID($target));
  }
};

var bindFontFamilySettingChange = function bindFontFamilySettingChange($fontFamilyField) {
  var $wrapper = $fontFamilyField.closest(fonts_wrapperSelector);
  var settingID = getSettingID($fontFamilyField);
  wp.customize(settingID, function (setting) {
    setting.bind(function (newValue, oldValue) {
      // this is a costly operation
      if (!isUpdating(settingID)) {
        loadFontValue($wrapper, newValue, settingID);
      }
    });
  });
};

var reloadConnectedFields = debounce(function () {
  var settingIDs = styleManager.fontPalettes.masterSettingIds;
  unbindConnectedFields(settingIDs);
  settingIDs.forEach(function (settingID) {
    wp.customize(settingID, function (parentSetting) {
      setCallback(settingID, function (newValue) {
        var settingConfig = getSetting(settingID);
        var connectedFields = settingConfig.connected_fields || {};
        Object.keys(connectedFields).forEach(function (key) {
          var connectedFieldData = connectedFields[key];
          var connectedSettingID = connectedFieldData.setting_id;
          var callbackFilter = getCallbackFilter(connectedFieldData);
          wp.customize(connectedSettingID, function (connectedSetting) {
            connectedSetting.set(callbackFilter(newValue));
          });
        });
      });
      parentSetting.bind(getCallback(settingID));
    });
  });
}, 30);
;// CONCATENATED MODULE: ./src/_js/customizer/font-palettes/index.js

var initializeFontPalettes = function initializeFontPalettes() {
  external_jQuery_default()('.js-font-palette').each(function (i, obj) {
    var $paletteSet = external_jQuery_default()(obj);
    var $labels = $paletteSet.find('label');
    $labels.on('click', function (event) {
      var $label = external_jQuery_default()(event.target);
      var forID = $label.attr('for');
      var $input = external_jQuery_default()("#".concat(forID));
      var fontsLogic = $input.data('fonts_logic');
      showAdvancedFontPaletteControls();
      applyFontPalette(fontsLogic);
    });
  }); // Handle the case when there is no selected font palette (like on a fresh installation without any demo data import).
  // In this case we want to hide the advanced tab.

  wp.customize('sm_font_palette', function (setting) {
    if (!setting()) {
      hideAdvancedFontPaletteControls();
    }
  });
};

var applyFontPalette = function applyFontPalette(fontsLogic) {
  external_jQuery_default().each(fontsLogic, function (settingID, config) {
    wp.customize(settingID, function (setting) {
      setting.set(config);
    });
  });
};

var advancedTabSelector = '#sub-accordion-section-sm_font_palettes_section .sm-tabs__item[data-target="advanced"]';

var hideAdvancedFontPaletteControls = function hideAdvancedFontPaletteControls() {
  external_jQuery_default()(advancedTabSelector).css('visibility', 'hidden');
};

var showAdvancedFontPaletteControls = function showAdvancedFontPaletteControls() {
  external_jQuery_default()(advancedTabSelector).css('visibility', 'visible');
};
;// CONCATENATED MODULE: ./src/_js/customizer/resizer/index.js
var defaultOffset = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var offset = defaultOffset;
wp.customize.bind('ready', function () {
  setOffset({
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  });
  resize();
  window.addEventListener('resize', resize);
  wp.customize.previewedDevice.bind(resize);
  wp.customize.previewer.bind('synced', function () {
    window.requestAnimationFrame(resize);
  });
  var collapseSidebar = document.querySelector('.collapse-sidebar');

  if (!collapseSidebar) {
    return;
  }

  collapseSidebar.addEventListener('click', function () {
    setTimeout(resize, 300);
  });
});
var setOffset = function setOffset(newOffset) {
  offset = Object.assign({}, newOffset);
};
var resize = function resize() {
  var preview = document.querySelector('.wp-full-overlay');

  if (!preview) {
    return;
  }

  var iframe = preview.querySelector('iframe');
  var previewedDevice = wp.customize.previewedDevice.get();

  if (!iframe) {
    return;
  } // remove CSS properties that may have been previously added


  iframe.style.removeProperty('width');
  iframe.style.removeProperty('height');
  iframe.style.removeProperty('transform-origin');
  iframe.style.removeProperty('transform');
  iframe.style.removeProperty('margin-top');
  iframe.style.removeProperty('margin-left'); // scaling of the site preview should be done only in desktop preview mode

  if (previewedDevice !== 'desktop') {
    return;
  }

  var windowWidth = window.innerWidth;
  var windowHeight = window.innerHeight;
  var previewWidth = preview.offsetWidth;
  var previewHeight = preview.offsetHeight; // for an accurate preview at resolutions where media queries may intervene
  // increase the width of the preview and use CSS transforms to scale it back down

  var shouldScale = previewWidth > 720 && previewWidth < 1100;
  var initialHeight = previewHeight;
  var finalHeight = previewHeight - offset.top - offset.bottom;
  var initialWidth = shouldScale ? windowWidth : previewWidth;
  var finalWidth = previewWidth - offset.left - offset.right;
  var scaleX = initialWidth / finalWidth;
  var scaleY = initialHeight / finalHeight;
  var scale = Math.max(scaleX, scaleY);
  iframe.style.width = "".concat(finalWidth * scale, "px");
  iframe.style.height = "".concat(finalHeight * scale, "px");
  iframe.style.transformOrigin = "left top";
  iframe.style.transform = "scale( ".concat(1 / scale, " )");
  iframe.style.marginTop = "".concat(offset.top, "px");
  iframe.style.marginLeft = "".concat(offset.left, "px");
};
;// CONCATENATED MODULE: ./src/_js/customizer/fields/color-select/index.js

var handleColorSelectFields = function handleColorSelectFields() {
  external_jQuery_default()('.js-color-select').each(function (i, obj) {
    convertToColorSelect(obj);
  });
};
var convertToColorSelect = function convertToColorSelect(element) {
  var $select = external_jQuery_default()(element);
  var $selectOptions = $select.find('option');
  var $colorSelect = external_jQuery_default()('<div class="style-manager-color-select">');
  var settingID = $select.data('customize-setting-link');
  var $optionsList = external_jQuery_default()('<div class="style-manager-color-select__option-list">');
  $selectOptions.each(function (i, option) {
    var $option = external_jQuery_default()(option);
    var label = $option.text();
    var value = $option.attr('value');
    var $colorSelectOptionLabel = external_jQuery_default()('<div class="style-manager-color-select__option-label">');
    var $colorSelectOption = external_jQuery_default()('<div class="style-manager-color-select__option">');
    $colorSelectOptionLabel.text(label).appendTo($colorSelectOption);
    $colorSelectOption.data('value', value).appendTo($optionsList);
    $colorSelectOption.addClass('style-manager-color-select__option--' + value);
  });
  $optionsList.appendTo($colorSelect);
  var $colorSelectOptions = $colorSelect.find('.style-manager-color-select__option');
  $colorSelectOptions.each(function (i, option) {
    var $colorSelectOption = external_jQuery_default()(option);
    var value = $colorSelectOption.data('value');
    $colorSelectOption.on('click', function () {
      $select.val(value).change();
    });
  });
  $colorSelect.insertBefore($select);
  $select.hide();

  function updateColorSelect(newValue) {
    var $colorSelectOption = $colorSelectOptions.filter(function (index, obj) {
      return external_jQuery_default()(obj).data('value') === newValue;
    });

    if ($colorSelectOption.length) {
      $colorSelectOptions.removeClass('style-manager-color-select__option--selected');
      $colorSelectOption.addClass('style-manager-color-select__option--selected');
    }
  }

  wp.customize(settingID, function (setting) {
    updateColorSelect(setting());
    setting.bind(updateColorSelect);
  });
};
;// CONCATENATED MODULE: ./src/_js/customizer/fields/range/index.js

var handleRangeFields = function handleRangeFields() {
  var rangeControlSelectors = [".accordion-section-content[id*=\"".concat(styleManager.config.options_name, "\"]"), "#sub-accordion-section-sm_color_palettes_section", "#sub-accordion-section-sm_color_usage_section"];
  var rangeControlSelector = rangeControlSelectors.join(', ');
  external_jQuery_default()(rangeControlSelector).each(function (i, container) {
    var $rangeFields = external_jQuery_default()(container).find('input[type="range"]'); // For each range input add a number field (for preview mainly - but it can also be used for input)

    $rangeFields.each(function (i, obj) {
      var $range = external_jQuery_default()(obj);
      var settingID = $range.data('customize-setting-link');
      var $number = $range.clone();
      $number.attr('type', 'text').attr('class', 'range-value').removeAttr('data-value_entry');
      $number.data('source', $range);

      if ($range.first().attr('id')) {
        $number.attr('id', $range.first().attr('id') + '_number');
      }

      $number.insertAfter($range);
      wp.customize(settingID, function (setting) {
        setting.bind(function (newValue) {
          $number.val(newValue);
        });
      }); // When clicking outside the number field or on Enter.

      $number.on('blur keyup', onRangePreviewBlur);
    });
  });
};

function onRangePreviewBlur(event) {
  var $number = external_jQuery_default()(event.target);
  var $range = $number.data('source');

  if ('keyup' === event.type && event.keyCode !== 13) {
    return;
  }

  if (event.target.value === $range.val()) {
    // Nothing to do if the values are identical.
    return;
  }

  if (!hasValidValue($number)) {
    $number.val($range.val());
    shake($number);
  } else {
    // Do not mark this trigger as being programmatically triggered by Style Manager since it is a result of a user input.
    $range.val($number.val()).trigger('change');
  }
}

function hasValidValue($input) {
  var min = $input.attr('min');
  var max = $input.attr('max');
  var value = $input.val();

  if (typeof min !== 'undefined' && parseFloat(min) > parseFloat(value)) {
    return false;
  }

  if (typeof max !== 'undefined' && parseFloat(max) < parseFloat(value)) {
    return false;
  }

  return true;
}

function shake($field) {
  $field.addClass('input-shake input-error');
  $field.one('animationend', function () {
    $field.removeClass('input-shake input-error');
  });
}
;// CONCATENATED MODULE: ./src/_js/customizer/fields/tabs/index.js

var handleTabs = function handleTabs() {
  external_jQuery_default()('.sm-tabs').each(function (i, obj) {
    var $wrapper = external_jQuery_default()(obj);
    var $section = $wrapper.closest('.control-section');
    var $tabs = $wrapper.children('.sm-tabs__item');
    var targets = $tabs.map(function (i, el) {
      var target = external_jQuery_default()(el).data('target');
      return "sm-view-".concat(target);
    });
    var targetClassnames = targets.toArray().join(" ");

    function setActiveTab($active) {
      var target = $active.data('target');
      $tabs.removeClass('sm-tabs__item--active');
      $active.addClass('sm-tabs__item--active');
      $section.removeClass(targetClassnames).addClass("sm-view-".concat(target));
    }

    $wrapper.on('click', '.sm-tabs__item', function (e) {
      e.preventDefault();
      setActiveTab(external_jQuery_default()(this));
    });
    setActiveTab($tabs.first());
  });
};
;// CONCATENATED MODULE: ./src/_js/customizer/folding-fields.js

/**
 * This function will search for all the interdependend fields and make a bound between them.
 * So whenever a target is changed, it will take actions to the dependent fields.
 * @TODO  this is still written in a barbaric way, refactor when needed
 */

var handleFoldingFields = function handleFoldingFields() {
  if (_.isUndefined(styleManager.config) || _.isUndefined(styleManager.config.settings)) {
    return; // bail
  }

  (external_jQuery_default()).fn.reactor.defaults.compliant = function () {
    external_jQuery_default()(this).slideDown();
    external_jQuery_default()(this).find(':disabled').attr({
      disabled: false
    });
  };

  (external_jQuery_default()).fn.reactor.defaults.uncompliant = function () {
    external_jQuery_default()(this).slideUp();
    external_jQuery_default()(this).find(':enabled').attr({
      disabled: true
    });
  };

  var IS = external_jQuery_default().extend({}, (external_jQuery_default()).fn.reactor.helpers);

  var bindFoldingEvents = function bindFoldingEvents(parentID, field, relation) {
    var key = null;

    if (_.isString(field)) {
      key = field;
    } else if (!_.isUndefined(field.id)) {
      key = field.id;
    } else if (_.isString(field[0])) {
      key = field[0];
    } else {
      return; // no key, no fun
    }

    var value = 1,
        // by default we use 1 the most used value for checkboxes or inputs
    between = [0, 1]; // can only be `show` or `hide`

    var target_key = styleManager.config.options_name + '[' + key + ']';
    var target_type = styleManager.config.settings[target_key].type; // we support the usual syntax like a config array like `array( 'id' => $id, 'value' => $value, 'compare' => $compare )`
    // but we also support a non-associative array like `array( $id, $value, $compare )`

    if (!_.isUndefined(field.value)) {
      value = field.value;
    } else if (!_.isUndefined(field[1]) && !_.isString(field[1])) {
      value = field[1];
    }

    if (!_.isUndefined(field.between)) {
      between = field.between;
    }
    /**
     * Now for each target we have, we will bind a change event to hide or show the dependent fields
     */


    var target_selector = '[data-customize-setting-link="' + styleManager.config.options_name + '[' + key + ']"]';

    switch (target_type) {
      case 'checkbox':
        external_jQuery_default()(parentID).reactIf(target_selector, function () {
          return external_jQuery_default()(this).is(':checked') == value;
        });
        break;

      case 'radio':
      case 'sm_radio':
      case 'sm_switch':
      case 'radio_image':
      case 'radio_html':
        // in case of an array of values we use the ( val in array) condition
        if (_.isObject(value)) {
          value = _.toArray(value);
          external_jQuery_default()(parentID).reactIf(target_selector, function () {
            return value.indexOf(external_jQuery_default()(target_selector + ':checked').val()) !== -1;
          });
        } else {
          // in any other case we use a simple == comparison
          external_jQuery_default()(parentID).reactIf(target_selector, function () {
            return external_jQuery_default()(target_selector + ':checked').val() == value;
          });
        }

        break;

      case 'range':
        var x = IS.Between(between[0], between[1]);
        external_jQuery_default()(parentID).reactIf(target_selector, x);
        break;

      default:
        // in case of an array of values we use the ( val in array) condition
        if (_.isObject(value)) {
          value = _.toArray(value);
          external_jQuery_default()(parentID).reactIf(target_selector, function () {
            return value.indexOf(external_jQuery_default()(target_selector).val()) !== -1;
          });
        } else {
          // in any other case we use a simple == comparison
          external_jQuery_default()(parentID).reactIf(target_selector, function () {
            return external_jQuery_default()(target_selector).val() == value;
          });
        }

        break;
    }

    external_jQuery_default()(target_selector).trigger('change', ['style-manager']);
    external_jQuery_default()('.reactor').trigger('change.reactor'); // triggers all events on load
  };

  external_jQuery_default().each(styleManager.config.settings, function (id, field) {
    /**
     * Here we have the id of the fields. but we know for sure that we just need his parent selector
     * So we just create it
     */
    var parentID = id.replace('[', '-');
    parentID = parentID.replace(']', '');
    parentID = '#customize-control-' + parentID + '_control'; // get only the fields that have a 'show_if' property

    if (field.hasOwnProperty('show_if')) {
      var relation = 'AND';

      if (!_.isUndefined(field.show_if.relation)) {
        relation = field.show_if.relation; // remove the relation property, we need the config to be array based only

        delete field.show_if.relation;
      }
      /**
       * The 'show_if' can be a simple array with one target like: [ id, value, comparison, action ]
       * Or it could be an array of multiple targets and we need to process both cases
       */


      if (!_.isUndefined(field.show_if.id)) {
        bindFoldingEvents(parentID, field.show_if, relation);
      } else if (_.isObject(field.show_if)) {
        external_jQuery_default().each(field.show_if, function (i, j) {
          bindFoldingEvents(parentID, j, relation);
        });
      }
    }
  });
};
;// CONCATENATED MODULE: ./src/_js/customizer/utils/api-set-setting-value.js
/**
 * Set a setting value.
 *
 * Mostly used for resetting settings (via the reset buttons) but also for the preset (legacy) field.
 *
 * @param settingID
 * @param value
 */
var apiSetSettingValue = function apiSetSettingValue(settingID, value) {
  var setting = api(settingID),
      field = $('[data-customize-setting-link="' + settingID + '"]'),
      fieldClass = $(field).parent().attr('class');

  if (!_.isUndefined(fieldClass) && fieldClass === 'font-options__wrapper') {
    // if the value is a simple string it must be the font family
    if (_.isString(value)) {
      setting.set({
        'font_family': value
      });
    } else if (_.isObject(value)) {
      var standardValue = {}; // We will process each font property and update it

      _.each(value, function (val, key) {
        // We need to map the keys to the data attributes we are using - I know :(
        var mappedKey = key;

        switch (key) {
          case 'font-family':
            mappedKey = 'font_family';
            break;

          case 'font-size':
            mappedKey = 'font_size';
            break;

          case 'font-weight':
            mappedKey = 'font_variant';
            break;

          case 'letter-spacing':
            mappedKey = 'letter_spacing';
            break;

          case 'text-transform':
            mappedKey = 'text_transform';
            break;

          default:
            break;
        }

        standardValue[mappedKey] = val;
      });

      setting.set(standardValue);
    }
  } else {
    setting.set(value);
  }
};
;// CONCATENATED MODULE: ./src/_js/customizer/create-reset-buttons.js


var createResetButtons = function createResetButtons() {
  var $document = external_jQuery_default()(document);
  var showResetButtons = external_jQuery_default()('button[data-action="reset_style_manager"]').length > 0;

  if (showResetButtons) {
    createResetPanelButtons();
    createResetSectionButtons();
    $document.on('click', '.js-reset-panel', onResetPanel);
    $document.on('click', '.js-reset-section', onResetSection);
    $document.on('click', '#customize-control-reset_style_manager button', onReset);
  }
};

function createResetPanelButtons() {
  external_jQuery_default()('.panel-meta').each(function (i, obj) {
    var $this = external_jQuery_default()(obj);
    var container = $this.parents('.control-panel');
    var id = container.attr('id');

    if (typeof id !== 'undefined') {
      id = id.replace('sub-accordion-panel-', '');
      id = id.replace('accordion-panel-', '');
      var $buttonWrapper = external_jQuery_default()('<li class="customize-control customize-control-reset"></li>');
      var $button = external_jQuery_default()('<button class="button js-reset-panel" data-panel="' + id + '"></button>');
      $button.text(styleManager.l10n.panelResetButton).appendTo($buttonWrapper);
      $this.parent().append($buttonWrapper);
    }
  });
}

function createResetSectionButtons() {
  external_jQuery_default()('.accordion-section-content').each(function (el, key) {
    var $this = external_jQuery_default()(this);
    var sectionID = $this.attr('id');

    if (_.isUndefined(sectionID) || sectionID.indexOf(styleManager.config.options_name) === -1) {
      return;
    }

    var id = sectionID.replace('sub-accordion-section-', '');
    var $button = external_jQuery_default()('<button class="button js-reset-section" data-section="' + id + '"></button>');
    var $buttonWrapper = external_jQuery_default()('<li class="customize-control customize-control-reset"></li>');
    $button.text(styleManager.l10n.sectionResetButton);
    $buttonWrapper.append($button);
    $this.append($buttonWrapper);
  });
}

function onReset(ev) {
  ev.preventDefault();
  var iAgree = confirm(styleManager.l10n.resetGlobalConfirmMessage);

  if (!iAgree) {
    return;
  }

  external_jQuery_default().each(api.settings.controls, function (key, ctrl) {
    var settingID = key.replace('_control', '');
    var setting = styleManager.config.settings[settingID];

    if (!_.isUndefined(setting) && !_.isUndefined(setting.default)) {
      apiSetSettingValue(settingID, setting.default);
    }
  });
  api.previewer.save();
}

function onResetPanel(e) {
  e.preventDefault();
  var panelID = external_jQuery_default()(this).data('panel'),
      panel = api.panel(panelID),
      sections = panel.sections(),
      iAgree = confirm(styleManager.l10n.resetPanelConfirmMessage);

  if (!iAgree) {
    return;
  }

  if (sections.length > 0) {
    external_jQuery_default().each(sections, function () {
      var controls = this.controls();

      if (controls.length > 0) {
        external_jQuery_default().each(controls, function (key, ctrl) {
          var settingID = ctrl.id.replace('_control', ''),
              setting = styleManager.config.settings[settingID];

          if (!_.isUndefined(setting) && !_.isUndefined(setting.default)) {
            apiSetSettingValue(settingID, setting.default);
          }
        });
      }
    });
  }
}

function onResetSection(e) {
  e.preventDefault();
  var sectionID = external_jQuery_default()(this).data('section'),
      section = api.section(sectionID),
      controls = section.controls();
  var iAgree = confirm(styleManager.l10n.resetSectionConfirmMessage);

  if (!iAgree) {
    return;
  }

  if (controls.length > 0) {
    external_jQuery_default().each(controls, function (key, ctrl) {
      var setting_id = ctrl.id.replace('_control', ''),
          setting = styleManager.config.settings[setting_id];

      if (!_.isUndefined(setting) && !_.isUndefined(setting.default)) {
        apiSetSettingValue(setting_id, setting.default);
      }
    });
  }
}
;// CONCATENATED MODULE: ./src/_js/customizer/fonts/utils/convert-font-variant.js
/**
 * Will convert an array of CSS like variants into their FVD equivalents. Web Font Loader expects this format.
 * @link https://github.com/typekit/fvd
 */
var convertFontVariantToFVD = function convertFontVariantToFVD(variant) {
  variant = String(variant);
  var fontStyle = 'n'; // normal

  if (-1 !== variant.indexOf('italic')) {
    fontStyle = 'i';
    variant = variant.replace('italic', '');
  } else if (-1 !== variant.indexOf('oblique')) {
    fontStyle = 'o';
    variant = variant.replace('oblique', '');
  }

  var fontWeight; //  The equivalence:
  //
  //			1: 100
  //			2: 200
  //			3: 300
  //			4: 400 (default, also recognized as 'normal')
  //			5: 500
  //			6: 600
  //			7: 700 (also recognized as 'bold')
  //			8: 800
  //			9: 900

  switch (variant) {
    case '100':
      fontWeight = '1';
      break;

    case '200':
      fontWeight = '2';
      break;

    case '300':
      fontWeight = '3';
      break;

    case '500':
      fontWeight = '5';
      break;

    case '600':
      fontWeight = '6';
      break;

    case '700':
    case 'bold':
      fontWeight = '7';
      break;

    case '800':
      fontWeight = '8';
      break;

    case '900':
      fontWeight = '9';
      break;

    default:
      fontWeight = '4';
      break;
  }

  return fontStyle + fontWeight;
};
;// CONCATENATED MODULE: ./src/_js/customizer/index.js












wp.customize.bind('ready', function () {
  loadSettings();
  var settings = getSettings();
  var settingIDs = Object.keys(settings);
  bindConnectedFields(settingIDs);
  createResetButtons();
  handleRangeFields();
  handleColorSelectFields();
  handleTabs(); // @todo check reason for this timeout

  setTimeout(function () {
    handleFoldingFields();
  }, 1000); // Initialize simple select2 fields.

  external_jQuery_default()('.style-manager_select2').select2();
  initializeColors();
  initializeFonts();
  initializeFontPalettes();
}); // expose API on sm.customizer global object




}();
(window.sm = window.sm || {}).customizer = __webpack_exports__;
/******/ })()
;